---
title: "Untitled"
output: html_document
date: "2025-09-04"
editor_options: 
  chunk_output_type: inline
---
```{r setup, include=FALSE,purl = T}
knitr::opts_chunk$set(purl = T)
```

```{r include=FALSE}
library(tidyverse)
library(raster)
library(mapview)
library(leaflet)
library(leafem)
library(rasterVis)
library(readxl)
library(sf)
library(pals)

library(Hmsc)
library(ape)
library(purrr)

main_theme = theme_minimal() +
 theme(aspect.ratio = 1,
        axis.text.x = element_text(colour = "black", size=13, face="italic",angle =45, vjust =1, hjust =1),
        axis.text.y = element_text(colour = "black", size=13, face="italic"),
        axis.title = element_text(colour = "black", size=12),
        panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
        legend.title = element_text(colour = "black", size=12,
                                    hjust =0.5),

        legend.text = element_text(colour = "black", size=13))

main_theme_final = theme_bw() +
 theme(aspect.ratio = 1,
        axis.text.x = element_text(colour = "black", size=7, face="italic", vjust =1, hjust =1),
        axis.text.y = element_text(colour = "black", size=7, face="italic"),
        axis.title = element_text(colour = "black", size=9),
        panel.border = element_rect(colour = "black", fill = NA, linewidth = 0.8),
        #panel.background = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title = element_text(colour = "black", size=9,
                                    hjust =0.5),
        legend.key.size = unit(0.3, 'cm'),
        legend.text = element_text(colour = "black", size=7,face="italic"),
        strip.background = element_blank(),
        strip.text = element_text(margin = margin(0.05,0,0.05,0, "cm"),size = 7),
        title = element_text(colour = "black", size=9))
```
# Spatial covariate

## Sampling points
```{r echo=FALSE}
metadata <- read_xlsx(path = "data/Metadata_Doreen_070525.xlsx")
soil_metadata <- read_xlsx(path = "data/soil_data_dry_season_2023.xlsx") %>% 
  select(-c(Zone, Cluster, Replicate,`Robusta coffee system`)) %>%
  rename(Sample_code = "SAMPLE NO",
          clay = "Clay%",
          N = "N%",
          OC = "OC%",
          pH = "soil pH",
          sand= "Sand%",
          silt = "Silt%",
          OM = "OM%",
          P = "P/mg/kg",
          K = "K/Cmol/kg",
          Na = "Na/Cmol/kg")

utm_coords <- metadata %>%
  mutate(
    zone = as.numeric(substr(easting, 1, 2)),
    band = substr(easting, 3, 3),
    easting = as.numeric(sub(".* ", "", easting)),
    northing = as.numeric(northing),

    hemisphere = ifelse(band == "N", "north", "south") # M = South Hemisphere
  )

# Function to convert a single row to lat/lon
convert_to_wgs84 <- function(zone, hemisphere, easting, northing,Sample_code) {
  epsg <- if (hemisphere == "north") {
    32600 + zone  # Northern hemisphere UTM EPSG codes
  } else {
    32700 + zone  # Southern hemisphere UTM EPSG codes
  }

  point <- st_sfc(st_point(c(easting, northing)), crs = epsg)
  point_wgs84 <- st_transform(point, crs = 4326)
  coords <- st_coordinates(point_wgs84)
  tibble( lon = coords[1], lat = coords[2],Sample_code = Sample_code)
}
utm_coords %>%
  mutate(zone = case_when(zone==32~ 36,
                             .default = zone),
          northing = case_when(Sample_code == "N17" ~ 86562,
                             .default = northing)) -> utm_coords
# Apply to each row
wgs84_coords <- pmap_dfr(utm_coords[, c("zone", "hemisphere", "easting", "northing","Sample_code")], convert_to_wgs84) %>%
  left_join(metadata, by = "Sample_code") %>%
  st_as_sf(coords = c("lon", "lat"),crs = 4326) %>%
  mutate(
     lon= st_coordinates(.)[,1],
     lat= st_coordinates(.)[,2]
  )


leaflet() %>% 
  addTiles() %>%
  addMarkers(data=wgs84_coords,~lon, ~lat, popup = ~paste(round(lat,2), round(lon,2)) , label = ~Sample_code)%>%
  addCircleMarkers(data = wgs84_coords, lng = ~lon,
                  lat = ~lat, radius = 8, color = "blue", fillOpacity = 0.8)
```

## NDVI

Indice for vegetation quantity 


https://planetarycomputer.microsoft.com/dataset/sentinel-3-synergy-v10-l2-netcdf

```{r echo=FALSE}
ndvi_uganda <- raster("outputs/raster/ndvi_uganda_lower_res.tif")

ndvi_df <- raster::extract(ndvi_uganda, wgs84_coords)%>%
 tibble(ndvi = .,
    Sample_code  = wgs84_coords$Sample_code)

pal_ndvi <- colorNumeric("viridis", domain = c(0, 1))
leaflet() %>%
  addTiles() %>% 
  addRasterImage(ndvi_uganda, opacity = 0.7) %>%
  addLegend(
    "bottomright",
    pal = pal_ndvi,
    values = c(0, 1),
  )
```

## Precipitation and Temperature max min

This is still work in progess, here the precipitation are for only **May 2023**. It is hard to get the data but I will try to obtain mean or sum precipitation for a hole year before June 2023.

```{r echo=FALSE}
precip_uganda_resampled <- raster("outputs/raster/precip_2023_lower_res.tif")

precip_df <- raster::extract(precip_uganda_resampled, wgs84_coords)%>%
 tibble(precip = .,
    Sample_code  = wgs84_coords$Sample_code)
pal_precip <- colorNumeric("Spectral", domain = c(0, 1))
leaflet() %>%
  addTiles() %>%
  addRasterImage(precip_uganda_resampled, opacity = 0.5)%>%
    addLegend(
    "bottomright",
    pal = pal_precip,
    values = c(0, 1),
  )

```

```{r echo=FALSE}
tmax_uganda_resampled <- raster("outputs/raster/tmax_2023_lower_res.tif")

tmax_df <- raster::extract(tmax_uganda_resampled, wgs84_coords)%>%
 tibble(tmax = .,
    Sample_code  = wgs84_coords$Sample_code)
pal_t <- colorNumeric("Spectral", domain = c(0, 34))
leaflet() %>%
  addTiles() %>%
  addRasterImage(tmax_uganda_resampled, opacity = 0.5)%>%
    addLegend(
    "bottomright",
    pal = pal_t,
    values = c(0, 34),
  )

```

```{r echo=FALSE}
tmin_uganda_resampled <- raster("outputs/raster/tmin_2023_lower_res.tif")

tmin_df <- raster::extract(tmin_uganda_resampled, wgs84_coords)%>%
 tibble(tmin = .,
    Sample_code  = wgs84_coords$Sample_code)
leaflet() %>%
  addTiles() %>%
  addRasterImage(tmin_uganda_resampled, opacity = 0.5)%>%
    addLegend(
    "bottomright",
    pal = pal_t,
    values = c(0, 34),
  )

```

```{r}
delta_t_uganda <- tmax_uganda_resampled -tmin_uganda_resampled

tdelta_df <- raster::extract(delta_t_uganda, wgs84_coords)%>%
 tibble(tdelta = .,
    Sample_code  = wgs84_coords$Sample_code)
tdelta_df %>% summary()
leaflet() %>%
  addTiles() %>%
  addRasterImage(delta_t_uganda, opacity = 0.5)%>%
    addLegend(
    "bottomright",
    pal = pal_t,
    values = c(9, 12),
  )
```

```{r echo=FALSE}
wind_2023 <- raster("outputs/raster/wind_2023.tif")
pal_wind <- colorNumeric("Spectral", domain = c(0, 4))
wind_df <- raster::extract(wind_2023, wgs84_coords)%>%
 tibble(wind = .,
    Sample_code  = wgs84_coords$Sample_code)
leaflet() %>%
  addTiles() %>%
  addRasterImage(wind_2023, opacity = 0.5)%>%
    addLegend(
    "bottomright",
    pal = pal_wind,
    values = c(0, 4),
  )

```

## Agroecological zone

```{r echo=FALSE}
wgs84_coords %>%
  left_join(soil_metadata, by = "Sample_code") %>%
  left_join(ndvi_df, by = "Sample_code") %>%
  left_join(precip_df, by = "Sample_code") %>%
  left_join(tmax_df, by = "Sample_code") %>%
  left_join(tmin_df, by = "Sample_code") %>%
  left_join(tdelta_df, by ="Sample_code") %>%
  left_join(wind_df, by ="Sample_code") -> wgs84_coords

```


# Joint species distribution models at the family level

```{r echo=FALSE}
amf_family_decont <- read.table("outputs/abundance_tables/Robust_MiSeq_18S_AMf_20241120_125_samples.OTU.filtered.cleaved.nosubstringOTUs.mumu.rarefy.family.txt", header = TRUE, stringsAsFactors = FALSE)
family_tree <- read.tree("outputs/phylo_tree/Robust_MiSeq_18S_AMf_20241120_125_samples_Eukaryome_Glomeromycota_family.tree")

# Inspect and root tree
family_tree$tip.label
plot(family_tree)
family_tree <- root(family_tree, "c__Archaeosporomycetes_4")

# Clean tip labels (example transformation)
family_rename <- family_tree$tip.label %>%
  str_remove("f__") %>%
  str_replace_all("[a-z]__", "Unknown ") %>%
  str_replace("_(\\d+)$", " (\\1 OTU)")
length(family_rename)
family_tree$tip.label <- family_rename
plot(family_tree)
str(family_tree)
```


```{r}
# Prepare Y matrix for families
amf_family_decont <- amf_family_decont %>%
  mutate(family = family %>%
           str_remove("f__") %>%
           str_replace_all("[a-z]__", "Unknown ") %>%
           str_replace("_(\\d+)$", " (\\1 OTU)")) %>%
  remove_rownames() %>%
  column_to_rownames("family")

Y_family <- amf_family_decont %>%
  filter(rowSums(across(starts_with("ROB")) != 0) > 3) %>%
  t()

# Prepare Y without zeros as a truncated version
Y_family_trucated <- Y_family %>%
  as.data.frame() %>%
  rownames_to_column("soil_code") %>%
  pivot_longer(-soil_code) %>%
  mutate(value = ifelse(value == 0, NA, value)) %>%
  pivot_wider(names_from = name, values_from = value) %>%
  column_to_rownames("soil_code")

# Filter tree to the families present in Y
family_tree_filter <- keep.tip(phy = family_tree, tip = colnames(Y_family))
Y_family <- Y_family[, family_tree_filter$tip.label]
Y_family_trucated <- Y_family_trucated[, family_tree_filter$tip.label]

# Sample names from Y
family_matrix_samples <- rownames(Y_family)

```

## Covariates

```{r}
library(GGally)
library(FactoMineR)
covariate_df <- wgs84_coords %>% 
  as.data.frame() %>%
  mutate(Sample_code = str_c("ROB_", Sample_code, "_s")) %>%
  filter(Sample_code %in% family_matrix_samples) %>%
  dplyr::select(Sample_code,ndvi,Robusta_coffee_system, precip, tmax, tmin,tdelta, wind,
                clay,OC,OM,N,sand,silt,pH,
                P, K, Na)

covariate_df %>%
  dplyr::filter(Sample_code %in% rownames(Y_family)) %>%
  dplyr::slice(match(rownames(Y_family), Sample_code)) %>%
  column_to_rownames("Sample_code") %>%
  mutate(across(where(is.numeric), ~vegan::decostand(.x, method = "standardize")[,1])) %>%
  rownames_to_column("Sample_code") %>%
  mutate(Sample_code = as.factor(Sample_code)) -> covariate_standa_df
# write.table(covariate_df, "outputs/covariate_table.txt")

covariate_standa_df %>%
  select(-Sample_code) %>%
  ggpairs(progress = F)


covariate_standa_df %>%
  select(where(is.numeric)) %>%
  PCA()

covariate_standa_df %>%
  na.omit() %>%
  select(ndvi, tmax, tdelta, wind, OC, Na,P, pH) %>%
  ggpairs(progress = F)

covariate_standa_df %>%
select(ndvi, tmax, tdelta, wind, OC, Na,P, pH) %>%
  PCA()
```



```{r}
library(sbm)
covariate_standa_df %>%
  column_to_rownames("Sample_code") %>%
  select(where(is.numeric)) %>%
  na.omit() %>%
  t() -> covariate_standa_numeric_df


covariate_standa_numeric_df %>%
  as.matrix() %>%
  estimateBipartiteSBM(model = "gaussian",dimLabels = c(row = "covariates", col = "sample_code")) -> variate_sbm
plot(variate_sbm)
```

```{r}
make_id_order_by_group_df <- function(.data, group_name){
.data%>%as.data.frame()%>%
  rownames_to_column("id")%>%
  mutate(id = as.numeric(id))%>%
  arrange({{group_name}})
}

sample_code_id = make_id_order_by_group_df(variate_sbm$memberships[2], sample_code)
covariates_id = make_id_order_by_group_df(variate_sbm$memberships[1], covariates)

covariate_standa_numeric_df[covariates_id$id, sample_code_id$id] %>%
  plotMyMatrix(dimLabels = c("Soil", "Grid"), plotOptions = list(rowNames = T,colNames = T))+
  theme(
    legend.position="none",
    axis.text.x =element_text(angle = 45, vjust = 1, hjust = 1, size = 6, face="italic"),
    axis.text.y = element_text(size = 5,face="italic"))+
  geom_vline(xintercept = which(!duplicated(sample_code_id$sample_code))[-1]-0.5, col ="red")+
  geom_hline(yintercept = abs(which(!duplicated(covariates_id$covariates))[-1]-nrow(covariates_id)-1)+0.5, col = "red", linetype = 5)+
  theme(strip.text.x = element_text(colour = "gray", size=15, face ="italic"),
        strip.text.y  = element_text(colour = "gray", size=15, face ="italic"),
        strip.background = element_rect(fill="white"),
        panel.border = element_rect(color = "black",  fill = NA))

covariate_standa_df %>%
  left_join(data.frame(Sample_code = colnames(covariate_standa_numeric_df),
                       cluster_covariates = variate_sbm$memberships[2]$sample_code),
            by ="Sample_code") -> covariate_standa_df
  
```


```{r echo=FALSE}

# 
# nChains = 12
# test.run = F
# if (test.run){
#   #with this option, the vignette runs fast but results are not reliable
#   thin = 5
#   samples = 10
#   transient = 5*thin
#   verbose = 5*thin
# } else {
#   #with this option, the vignette evaluates slow but it reproduces the results of the
#   #.pdf version
#   thin = 10
#   samples = 750
#   transient = 1000*thin
#   verbose = 1000*thin
# }
# covariate_standa_df %>%
#   filter(Sample_code != "ROB_M19_s")  -> covariate_standa_filter_df
# Y_family %>%
#   as.data.frame() %>%
#   rownames_to_column("Sample_code") %>%
#   filter(Sample_code != "ROB_M19_s") %>%
#   column_to_rownames("Sample_code") %>%
#   as.matrix() -> Y_family_filter
studyDesign <- data.frame(sample = rownames(Y_family), stringsAsFactors = TRUE)
rL <- HmscRandomLevel(units = studyDesign$sample)
```


```{r echo=FALSE}

# Y_family_filter %>% 
#   rowSums %>% 
#   as.data.frame() %>%
#   rename(readscount = ".") %>%
#   rownames_to_column("Sample_code") -> readscount_df
# 
# covariate_standa_filter_df %>%
#   left_join(readscount_df, by = "Sample_code") %>%
#   mutate(Sample_code = as.factor(Sample_code)) -> covariate_standa_filter_df
covariate_standa_df %>%
  na.omit() %>%
  pull(Sample_code) -> sample_code_to_use

Y_family2 <- Y_family[rownames(Y_family) %in% sample_code_to_use,]

all(rownames(Y_family2) == covariate_standa_df %>%
                          na.omit %>% pull(Sample_code))
studyDesign2 <- data.frame(sample = rownames(Y_family2), stringsAsFactors = TRUE)
rL2 <- HmscRandomLevel(units = studyDesign$sample)

covariate_standa_df %>%
  mutate(Robusta_coffee_system = as.factor(Robusta_coffee_system), 
         cluster_covariates = as.factor(cluster_covariates),
         Sample_code = as.factor(Sample_code)) -> covariate_standa_df
```


```{r echo=FALSE}
mod_pois_cluster <- Hmsc(
  Y = log1p(Y_family2),
  XData =  covariate_standa_df %>% na.omit,
  XFormula = ~ Robusta_coffee_system + cluster_covariates,
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign2,
  ranLevels = list(sample = rL2),
  distr = "poisson"
)


colnames(Y_family_trucated) == covariate_standa_df$Sample_code

mod_pois_trunc_null <- Hmsc(
  Y = Y_family_trucated,
  XData =  covariate_standa_df ,
  XFormula = ~ 1,
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "poisson"
)

# mod_pois_ndvi <- Hmsc(
#   Y = Y_family,
#   XData = covariate_standa_df,
#   XFormula = ~ ndvi,
#   #phyloTree = family_tree_filter,
#   studyDesign = studyDesign,
#   ranLevels = list(sample = rL),
#   distr = "poisson"
# )
# 
# 
# mod_pois_precip <- Hmsc(
#   Y = Y_family,
#   XData = covariate_standa_df,
#   XFormula = ~ precip,
#   #phyloTree = family_tree_filter,
#   studyDesign = studyDesign,
#   ranLevels = list(sample = rL),
#   distr = "poisson"
# )
# 
# mod_pois_tmax <- Hmsc(
#   Y = Y_family,
#   XData =  covariate_standa_df,
#   XFormula = ~ tmax,
#   #phyloTree = family_tree_filter,
#   studyDesign = studyDesign,
#   ranLevels = list(sample = rL),
#   distr = "poisson"
# )
# 
# mod_pois_wind  <- Hmsc(
#   Y = Y_family,
#   XData = covariate_standa_df,
#   XFormula = ~ wind,
#   #phyloTree = family_tree_filter,
#   studyDesign = studyDesign,
#   ranLevels = list(sample = rL),
#   distr = "poisson"
# )

mod_pois_trunc_full <- Hmsc(
  Y = Y_family_trucated,
  XData = covariate_standa_df,
  XFormula = ~ ndvi + precip + tmax +tdelta + wind,
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "poisson"
)

mod_pois_trunc_poly <- Hmsc(
  Y = Y_family_trucated,
  XData = covariate_standa_df,
  XFormula = ~poly(ndvi,2) + poly(precip,2) + poly(tmax,2) + poly(tdelta,2) + poly(wind,2),
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "poisson"
)
mod_pois_null_log <- Hmsc(
  Y = log1p(Y_family),
  XData =  covariate_standa_df ,
  XFormula = ~ 1,
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "poisson"
)

mod_pois_full_log <- Hmsc(
  Y = log1p(Y_family),
  XData = covariate_standa_df,
  XFormula = ~ ndvi + precip + tmax +tdelta + wind,
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "poisson"
)

mod_pois_poly_log <- Hmsc(
  Y = log1p(Y_family),
  XData = covariate_standa_df,
  XFormula = ~poly(ndvi,2) + poly(precip,2) + poly(tmax,2) + poly(tdelta,2) + poly(wind,2),
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "poisson"
)

mod_pois_null_trunc_log <- Hmsc(
  Y = log(Y_family_trucated),
  XData =  covariate_standa_df ,
  XFormula = ~ 1,
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "poisson"
)

mod_pois_full_trunc_log <- Hmsc(
  Y = log(Y_family_trucated),
  XData = covariate_standa_df,
  XFormula = ~ ndvi + precip + tmax +tdelta + wind,
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "poisson"
)

mod_pois_poly_trunc_log <- Hmsc(
  Y = log(Y_family_trucated),
  XData = covariate_standa_df,
  XFormula = ~poly(ndvi,2) + poly(precip,2) + poly(tmax,2) + poly(tdelta,2) + poly(wind,2),
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "poisson"
)

mod_lognorm_null <- Hmsc(
  Y = Y_family,
  XData =  covariate_standa_df ,
  XFormula = ~ 1,
  #phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "lognormal poisson"
)

mod_lognorm_full <- Hmsc(
  Y = Y_family,
  XData = covariate_standa_df,
  XFormula = ~ ndvi + precip + tmax +tdelta + wind,
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "lognormal poisson"
)

mod_lognorm_poly <- Hmsc(
  Y = Y_family,
  XData = covariate_standa_df,
  XFormula = ~poly(ndvi,2) + poly(precip,2) + poly(tmax,2) + poly(tdelta,2) + poly(wind,2),
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "lognormal poisson"
)

mod_lognorm_null_log <- Hmsc(
  Y = log1p(Y_family),
  XData =  covariate_standa_df ,
  XFormula = ~ 1,
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "lognormal poisson"
)

mod_lognorm_full_log <- Hmsc(
  Y = log1p(Y_family),
  XData = covariate_standa_df,
  XFormula = ~ ndvi + precip + tmax +tdelta + wind,
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "lognormal poisson"
)

mod_lognorm_poly_log <- Hmsc(
  Y = log1p(Y_family),
  XData = covariate_standa_df,
  XFormula = ~poly(ndvi,2) + poly(precip,2) + poly(tmax,2) + poly(tdelta,2) + poly(wind,2),
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "lognormal poisson"
)

mod_lognorm_null_trunc <- Hmsc(
  Y = Y_family_trucated,
  XData =  covariate_standa_df ,
  XFormula = ~ 1,
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "lognormal poisson"
)

mod_lognorm_full_trunc <- Hmsc(
  Y = Y_family_trucated,
  XData = covariate_standa_df,
  XFormula = ~ ndvi + precip + tmax +tdelta + wind,
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "lognormal poisson"
)

mod_lognorm_poly_trunc <- Hmsc(
  Y = Y_family_trucated,
  XData = covariate_standa_df,
  XFormula = ~poly(ndvi,2) + poly(precip,2) + poly(tmax,2) + poly(tdelta,2) + poly(wind,2),
  # phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "lognormal poisson"
)


model_list <- list(
  mod_lognorm_null_trunc   = mod_lognorm_null_trunc,
  mod_lognorm_full_trunc   = mod_lognorm_full_trunc,
  mod_lognorm_poly_trunc   = mod_lognorm_poly_trunc,
  mod_pois_trunc_null      = mod_pois_trunc_null,
  # mod_pois_ndvi      = mod_pois_ndvi,
  # mod_pois_precip    = mod_pois_precip,
  # mod_pois_tmax      = mod_pois_tmax,
  # mod_pois_wind      = mod_pois_wind,
  mod_pois_trunc_full      = mod_pois_trunc_full,
  mod_pois_trunc_poly      = mod_pois_trunc_poly,
  mod_pois_null_log  = mod_pois_null_log,
  mod_pois_full_log  = mod_pois_full_log,
  mod_pois_poly_log  = mod_pois_poly_log,
  mod_pois_null_trunc_log  = mod_pois_null_trunc_log,
  mod_pois_full_trunc_log  = mod_pois_full_trunc_log,
  mod_pois_poly_trunc_log  = mod_pois_poly_trunc_log,
  mod_lognorm_null   = mod_lognorm_null,
  mod_lognorm_full   = mod_lognorm_full,
  mod_lognorm_poly   = mod_lognorm_poly,
  mod_lognorm_null_log   = mod_lognorm_null_log,
  mod_lognorm_full_log   = mod_lognorm_full_log,
  mod_lognorm_poly_log   = mod_lognorm_poly_log
)

```


```{r echo=FALSE}
compute.hmsc <- function(hmsc_mod, nfold = 10, nChains = 12,   test.run = T){

  if (test.run){
    #with this option, the vignette runs fast but results are not reliable
    thin = 5
    samples = 10
    transient = 5*thin
    verbose = 5*thin
  } else {
    #with this option, the vignette evaluates slow but it reproduces the results of the
    #.pdf version
    thin = 10
    samples = 1000
    transient = 1000*thin
    verbose = 1000*thin
  }
  
  m_converg <- sampleMcmc(
    hmsc_mod,
    thin = thin, samples = samples, transient = transient,
    nChains = nChains, verbose = verbose, nParallel = nChains)
  
  set.seed(92828)
  partition = createPartition(m_converg, nfolds = nfold, column = "sample")
  
  expl_power = computePredictedValues(m_converg, thin = thin, nParallel = nChains)
  MF_expl = evaluateModelFit(hM = m_converg, predY = expl_power) 
  
  #Predictive power based on cross-validation  

  pred_power = computePredictedValues(m_converg, partition = partition, thin = thin, nParallel = nChains)
  MF_pred = evaluateModelFit(hM = m_converg, predY = pred_power)
  
  mPredY <- apply(abind::abind(pred_power, along = 3), c(1, 2), matrixStats::mean2)
  
  colnames(mPredY) <- colnames(m_converg$Y)
  rownames(mPredY) <- rownames(m_converg$Y)
  
  list(hmsc_mod = hmsc_mod, m_converg = m_converg , mPredY = mPredY, MF_expl = MF_expl, MF_pred = MF_pred)
  }
# save(m_converg, file = "outputs/hmsc_family_full.Rdata")
# load(file = "outputs/hmsc_family_full.Rdata")

```

```{r}
compute.hmsc(mod_pois_cluster, nfold = 10, nChains = 12,   test.run =F) -> crossvalidation_mod_pois_cluster
extract.pred.power(crossvalidation_mod_pois_cluster,mod_ID = "mod_pois_cluster") -> mod_pois_cluster_crossvalidation_df

mod_pois_cluster_crossvalidation_df %>%
  mutate(pred_abund = exp(pred_abund)-1,
         true_abund = exp(true_abund)-1) -> mod_pois_cluster_crossvalidation_df
  str(mod_pois_cluster_crossvalidation_df)

  mod_pois_cluster_crossvalidation_df %>%
              group_by(family_names) %>%
              summarise(median_abund = median(true_abund, na.rm = T),
                        RMSE_perso = sqrt(median(pred_abund - true_abund, na.rm = TRUE)^2),
                        mean_abund = mean(true_abund, na.rm = T),
                        sd_abund = sd(true_abund, na.rm = T),
                        median_pred = median(pred_abund, na.rm = T),
                        mean_pred = mean(pred_abund, na.rm = T),
                        sd_pred = sd(pred_abund, na.rm = T)) %>%
  mutate(ratio_RMSE_sd = (RMSE_perso)/sd_abund) -> recap_pred_df
  
recap_pred_df %>%
  #filter(!(mod_ID %in% c(1,2,3,4))) %>%
 
  ggplot() +
  geom_point(aes(family_names, ratio_RMSE_sd),cex = 3, alpha =0.8) +
  scale_y_log10() +
  scale_color_viridis(discrete = T)+
  main_theme

recap_pred_df %>%
  #filter(!(mod_ID %in% c(1,2,3,4))) %>%
  ggplot() +
  geom_point(aes(family_names, RMSE_perso), cex = 4) +
  scale_y_log10() +
  scale_color_viridis(discrete = T)+
  main_theme

recap_pred_df %>%
  #filter(!(mean_pred>5000 & mod_ID ==4 )) %>%
  ggplot() +
  geom_abline(slope=1) +
  geom_point(aes(mean_abund, mean_pred, col = family_names), cex =3)+
  scale_x_log10() +
  scale_y_log10() +
  main_theme

mod_pois_cluster_crossvalidation_df %>%
  ggplot()+
  #facet_wrap(~mod_ID, scale = "free")+
  geom_point(aes(true_abund,pred_abund)) +
  geom_smooth(aes(true_abund, pred_abund), method = "lm") +
  geom_abline(slope=1) +
  scale_x_log10() +
  scale_y_log10() +
  labs(x= "Observed abundances", y = "Predicted abudances") +
  main_theme

mod_pois_cluster_crossvalidation_df %>%
  ggplot()+
  facet_wrap(~family_names, scale = "free")+
  geom_point(aes(true_abund,pred_abund)) +
  geom_smooth(aes(true_abund, pred_abund), method = "lm") +
  geom_abline(slope=1) +
  scale_x_log10() +
  scale_y_log10() +
  labs(x= "Observed abundances", y = "Predicted abudances") +
  main_theme
```

```{r}

# 1:length(model_list) %>%
#   purrr::map(\(x) compute.hmsc(model_list[[x]], nfold = 2, nChains = 12,   test.run =F)) -> list_mods_crossvalidation
# 
# save(list_mods_crossvalidation,file =  "outputs/list_mods_crossvalidation_family.RData")
load(file = "outputs/list_mods_crossvalidation_family.RData")
```

```{r, purl = FALSE}

extract.pred.power <- function(mod_crossvalidation, mod_ID){

  mod_crossvalidation[["mPredY"]] %>%
      as.data.frame() %>%
      rownames_to_column("Sample_code") %>%
      pivot_longer(-Sample_code, names_to = "family_names", values_to = "pred_abund") -> mPredY_long
  
  mod_crossvalidation[["m_converg"]]$Y %>%
    as.data.frame() %>%
    rownames_to_column("Sample_code") %>%
    pivot_longer(-Sample_code, names_to = "family_names", values_to = "true_abund") -> true_data_long
  
  mPredY_long %>%
    left_join(true_data_long, by = join_by(family_names,Sample_code)) %>%
    mutate (mod_ID = mod_ID) -> abund_df
  
  abund_df
}
list_truncated_model_ID <- list("lognorm_null_trunc",
  "lognorm_full_trunc",
  "lognorm_poly_trunc",
  "pois_trunc_null",
  "pois_trunc_full",
  "pois_trunc_poly",
  "pois_null_log",
  "pois_full_log",
  "pois_poly_log",
  "pois_null_trunc_log",
  "pois_full_trunc_log",
  "pois_poly_trunc_log",
  "lognorm_null",
  "lognorm_full",
  "lognorm_poly",
  "lognorm_null_log",
  "lognorm_full_log",
  "lognorm_poly_log"
  )


1:length(model_list) %>%
  purrr::map(\(x) extract.pred.power(list_mods_crossvalidation[[x]],mod_ID = list_truncated_model_ID[[x]])) %>%
  bind_rows() %>%
  # Standartise to raw abundance for log1p or log models
  mutate(pred_abund = case_when(mod_ID %in% c("pois_null_log",
                                              "pois_full_log",
                                              "pois_poly_log",
                                              "lognorm_null_log",
                                              "lognorm_full_log",
                                              "lognorm_poly_log") ~ exp(pred_abund)-1,
                          .default = pred_abund),
         true_abund = case_when(mod_ID %in% c("pois_null_log",
                                              "pois_full_log",
                                              "pois_poly_log",
                                              "lognorm_null_log",
                                              "lognorm_full_log",
                                              "lognorm_poly_log") ~ exp(true_abund)-1,
                          .default = true_abund),
         pred_abund = case_when(mod_ID %in% c("pois_null_trunc_log",
                                              "pois_full_trunc_log",
                                              "pois_poly_trunc_log") ~ exp(pred_abund),
                                                .default = pred_abund),
         true_abund = case_when(mod_ID %in% c("pois_null_trunc_log",
                                              "pois_full_trunc_log",
                                              "pois_poly_trunc_log") ~ exp(true_abund),
                                                                      .default = true_abund),
         true_abund = case_when(is.na(true_abund) ~ 0,
                          .default = true_abund))-> mods_crossvalidation_df



1:length(model_list)%>%
  purrr::map(\(x) list_mods_crossvalidation[[x]][["MF_pred"]] %>%
               as.data.frame() %>%
               mutate(family_names = colnames(Y_family),
                      mod_ID = list_truncated_model_ID[[x]])) %>%
  bind_rows() %>%
  mutate(RMSE = case_when(mod_ID %in% c("pois_null_log",
                                              "pois_full_log",
                                              "pois_poly_log",
                                              "lognorm_null_log",
                                              "lognorm_full_log",
                                              "lognorm_poly_log",
                                              "pois_null_trunc_log",
                                              "pois_full_trunc_log",
                                              "pois_poly_trunc_log") ~ exp(RMSE),
                        .default = RMSE)) %>%
  left_join(mods_crossvalidation_df %>%
              group_by(family_names, mod_ID) %>%
              summarise(median_abund = median(true_abund, na.rm = T),
                        mean_abund = mean(true_abund, na.rm = T),
                        sd_abund = sd(true_abund, na.rm = T),
                        median_pred = median(pred_abund, na.rm = T),
                        mean_pred = mean(pred_abund, na.rm = T),
                        sd_pred = sd(pred_abund, na.rm = T)),
            by = join_by(family_names== family_names, mod_ID==mod_ID)) %>%
  mutate(ratio_RMSE_sd = (RMSE)/sd_abund) -> recap_pred_df

# 1:length(model_list) %>%
#   purrr::map(\(x) list_mods_crossvalidation[[x]][["MF_expl"]] %>%
#                as.data.frame %>%
#                mutate(family_names = colnames(Y_family),
#                       mod_ID = x)) %>%
#   bind_rows() %>%
#   mutate(RMSE = case_when(mod_ID %in% c(7,8,9,10,11,12,16,17,18) ~ exp(RMSE),
#                           .default = RMSE))-> recap_expl_df

```

```{r, purl = FALSE}
# recap_expl_df %>%
#   group_by(mod_ID) %>%
#   summarise(mean_rmse = mean(RMSE)) %>%
#   ggplot() +
#   geom_point(aes(mod_ID, mean_rmse)) +
#   scale_y_log10() +
#   main_theme

# recap_expl_df %>%
#   group_by(mod_ID) %>%
#   summarise(mean_rmse_expl = mean(RMSE)) %>%
#   left_join(recap_pred_df %>%
#     group_by(mod_ID) %>%
#     summarise(mean_rmse_pred = mean(RMSE)), by = "mod_ID") %>%
#   ggplot() +
#   geom_point(aes(mod_ID,mean_rmse_pred/mean_rmse_expl, col = as.factor(mod_ID)))

```

```{r, purl = FALSE}
library(viridis)
recap_pred_df %>%
  #filter(!(mod_ID %in% c(1,2,3,4))) %>%
 
  ggplot() +
   facet_wrap(~mod_ID) +
  geom_point(aes(family_names, ratio_RMSE_sd),cex = 3, alpha =0.8) +
  scale_y_log10() +
  scale_color_viridis(discrete = T)+
  main_theme

recap_pred_df %>%
  #filter(!(mod_ID %in% c(1,2,3,4))) %>%
  ggplot() +
    facet_wrap(~mod_ID) +
  geom_point(aes(family_names, RMSE), cex = 4) +
  scale_y_log10() +
  scale_color_viridis(discrete = T)+
  main_theme

recap_pred_df %>%
  #filter(!(mean_pred>5000 & mod_ID ==4 )) %>%
  ggplot() +
  geom_abline(slope=1) +
  geom_point(aes(mean_abund, mean_pred, col = family_names), cex =3)+
  facet_wrap(~mod_ID, scale = "free")+
  scale_x_log10() +
  scale_y_log10() +
  main_theme

recap_pred_df %>%
  group_by(mod_ID) %>%
  summarise(RMSE_mean = mean(RMSE)) %>%
  arrange(RMSE_mean)
```

```{r, purl = FALSE}
mods_crossvalidation_df %>%
  ggplot()+
  facet_wrap(~mod_ID, scale = "free")+
  geom_point(aes(true_abund,pred_abund)) +
  geom_smooth(aes(true_abund, pred_abund), method = "lm") +
  geom_abline(slope=1) +
  scale_x_log10() +
  scale_y_log10() +
  labs(x= "Observed abundances", y = "Predicted abudances") +
  main_theme


mods_crossvalidation_df %>%

  ggplot()+

  geom_point(aes(true_abund,pred_abund), cex = 4) +
  facet_wrap(~family_names)+
    #facet_grid(col = vars(family_names), row = vars(mod_ID), scale  = "free") +
  geom_abline(slope=1) +
    scale_x_log10() +
  scale_y_log10() +
  labs(x= "Observed abundances", y = "Predicted abudances")+
  main_theme

mods_crossvalidation_df %>%
 #filter(mod_ID == 9, family_names != "Unknown Gigasporales (6 OTU)") %>%
  ggplot()+

  geom_point(aes(true_abund,pred_abund, col = log(pred_abund/(true_abund+1))), cex = 4) +
  facet_wrap(~family_names)+
    #facet_grid(col = vars(family_names), row = vars(mod_ID), scale  = "free") +
  geom_abline(slope=1) +
  labs(x= "Observed abundances", y = "Predicted abudances")+
  scale_x_log10() +
  scale_y_log10() +
  scale_color_gradientn(colors = topo.colors(50)) +
  main_theme


mods_crossvalidation_df %>%
 filter(str_detect(mod_ID, "log$") ,family_names != "Unknown Gigasporales (6 OTU)") %>%
  ggplot()+

  geom_point(aes(true_abund,pred_abund, col = family_names), cex = 4, alpha = 0.6) +
  facet_wrap(~mod_ID, scale ="free")+
    #facet_grid(col = vars(family_names), row = vars(mod_ID), scale  = "free") +
  geom_abline(slope=1) +
  labs(x= "Observed abundances", y = "Predicted abudances")+
  scale_x_log10() +
  scale_y_log10() +
  scale_color_viridis(discrete = T) +
  main_theme

mods_crossvalidation_df %>%
  filter(mod_ID %in% c(8,9),family_names != "Unknown Gigasporales (6 OTU)") %>%
  mutate(mod_ID = case_when(mod_ID == 8 ~"null_mod",
                            mod_ID == 9 ~"add_mod")) %>%
  pivot_wider(names_from = mod_ID, values_from = pred_abund) %>%
  ggplot()+
  geom_point(aes(null_mod,add_mod, col = log(add_mod/(true_abund+1))), cex = 4) +
  facet_wrap(~family_names)+
    #facet_grid(col = vars(family_names), row = vars(mod_ID), scale  = "free") +
  geom_abline(slope=1) +
  labs(x= "Predicted null", y = "Predicted additive")+
  scale_x_log10() +
  scale_y_log10() +
  scale_color_gradientn(colors = topo.colors(50))
  main_theme

```

# Occurence model

```{r}
Y_family_bin <- Y_family %>%
  as.data.frame() %>%
  rownames_to_column("soil_code") %>%
  pivot_longer(-soil_code) %>%
  mutate(value = ifelse(value == 0, 0, 1)) %>%
  pivot_wider(names_from = name, values_from = value) %>%
  column_to_rownames("soil_code")
```

```{r echo=FALSE}
mod_bin_null <- Hmsc(
  Y = Y_family_bin,
  XData =  covariate_standa_df ,
  XFormula = ~ 1,
  phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "probit"
)

mod_bin_ndvi <- Hmsc(
  Y = Y_family_bin,
  XData = covariate_standa_df,
  XFormula = ~ ndvi,
  phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "probit"
)


mod_bin_precip <- Hmsc(
  Y = Y_family_bin,
  XData = covariate_standa_df,
  XFormula = ~ precip,
  phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "probit"
)

mod_bin_tmax <- Hmsc(
  Y = Y_family_bin,
  XData =  covariate_standa_df,
  XFormula = ~ tmax,
  phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "probit"
)

mod_bin_wind  <- Hmsc(
  Y = Y_family_bin,
  XData = covariate_standa_df,
  XFormula = ~ wind,
  phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "probit"
)

mod_bin_full <- Hmsc(
  Y = Y_family_bin,
  XData = covariate_standa_df,
  XFormula = ~ ndvi + precip + tmax +tdelta + wind,
  phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "probit"
)

mod_bin_poly <- Hmsc(
  Y = Y_family_bin,
  XData = covariate_standa_df,
  XFormula = ~poly(ndvi,2) + poly(precip,2) + poly(tmax,2) + poly(tdelta,2) + poly(wind,2),
  phyloTree = family_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "probit"
)



model_bin_list <- list(
  mod_bin_null      = mod_bin_null,
  # mod_bin_ndvi      = mod_bin_ndvi,
  # mod_bin_precip    = mod_bin_precip,
  # mod_bin_tmax      = mod_bin_tmax,
  # mod_bin_wind      = mod_bin_wind,
  mod_bin_full      = mod_bin_full,
  mod_bin_poly      = mod_bin_poly
)
```

```{r}

# 1:length(model_bin_list) %>%
#   purrr::map(\(x) compute.hmsc(model_bin_list[[x]], nfold = 2, nChains = 12,   test.run = F)) -> list_mods_bin_crossvalidation
# 
# save(list_mods_bin_crossvalidation, file = "outputs/list_mods_bin_crossvalidation_family.RData")
load(file = "outputs/list_mods_bin_crossvalidation_family.RData")
```

```{r, purl = FALSE}

extract.pred.power <- function(mod_crossvalidation, mod_ID){

  mod_crossvalidation[["mPredY"]] %>%
      as.data.frame() %>%
      rownames_to_column("Sample_code") %>%
      pivot_longer(-Sample_code, names_to = "family_names", values_to = "pred_abund") -> mPredY_long
  
  mod_crossvalidation[["m_converg"]]$Y %>%
    as.data.frame() %>%
    rownames_to_column("Sample_code") %>%
    pivot_longer(-Sample_code, names_to = "family_names", values_to = "true_abund") -> true_data_long
  
  mPredY_long %>%
    left_join(true_data_long, by = join_by(family_names,Sample_code)) %>%
    mutate (mod_ID = mod_ID) -> abund_df
  
  abund_df
}

1:length(model_bin_list) %>%
  purrr::map(\(x) extract.pred.power(list_mods_bin_crossvalidation[[x]],mod_ID = x)) %>%
  bind_rows() -> mods_bin_crossvalidation_df


1:length(model_bin_list)%>%
  purrr::map(\(x) list_mods_bin_crossvalidation[[x]][["MF_pred"]] %>%
               as.data.frame %>%
               mutate(family_names = colnames(Y_family),
                      mod_ID = x)) %>%
  bind_rows() %>%
  left_join( mods_bin_crossvalidation_df %>%
    group_by(family_names,mod_ID) %>%
    summarise(
              mean_abund = mean(true_abund, na.rm = T),
              sd_abund = sd(true_abund, na.rm = T),
            
              mean_pred = mean(pred_abund, na.rm = T),
              sd_pred = sd(pred_abund, na.rm = T)), by = join_by(family_names== family_names, mod_ID==mod_ID)) -> recap_pred_bin_df

1:length(model_bin_list) %>%
  purrr::map(\(x) list_mods_bin_crossvalidation[[x]][["MF_expl"]] %>%
               as.data.frame %>%
               mutate(family_names = colnames(Y_family),
                      mod_ID = x)) %>%
  bind_rows() -> recap_expl_bin_df

```

```{r, purl = FALSE}
recap_expl_bin_df %>%
  group_by(mod_ID) %>%
  summarise(mean_auc_expl = mean(AUC, na.rm = T)) %>%
  ggplot() +
  geom_point(aes(as.factor(mod_ID), mean_auc_expl)) +
  main_theme

recap_pred_bin_df %>%
  group_by(mod_ID) %>%
  summarise(mean_auc_pred = mean(AUC, na.rm = T)) %>%
  ggplot() +
  geom_point(aes(as.factor(mod_ID), mean_auc_pred)) +
  main_theme

```

```{r, purl = FALSE}
library(viridis)
recap_pred_bin_df %>%
  #filter(!(mod_ID %in% c(1,2,3,4))) %>%
  ggplot() +
  geom_point(aes(family_names, AUC, col = as.factor(mod_ID)),cex = 3, alpha =0.8) +
  scale_color_viridis(discrete = T)+
  main_theme

recap_pred_bin_df %>%
  #filter(!(mean_pred>5000 & mod_ID ==4 )) %>%
  ggplot() +
  geom_abline(slope=1) +
  geom_point(aes(mean_abund, mean_pred, col = family_names), cex =3)+
  facet_wrap(~mod_ID, scale = "free")+
  main_theme

recap_pred_bin_df %>%
  group_by(mod_ID) %>%
  summarise(mean(RMSE))
```

```{r, purl = FALSE}
mods_bin_crossvalidation_df %>%
  ggplot()+
  facet_wrap(~mod_ID, scale = "free")+
  geom_point(aes(pred_abund,true_abund)) +
  geom_smooth(aes(pred_abund,true_abund), method = "glm") +
  geom_abline(slope=1) +
  labs(x= "Predicted occurance", y = "Observed occurance") +
  main_theme


mods_bin_crossvalidation_df %>%
  filter(mod_ID == 3) %>%
  ggplot()+
  facet_wrap(~family_names) +
  geom_point(aes(pred_abund,true_abund)) +
  geom_smooth(aes(pred_abund,true_abund), method = "glm") +
  geom_abline(slope=1) +
  labs(x= "Predicted occurance", y = "Observed occurance") +
  main_theme

recap_pred_bin_df %>%
  filter(mod_ID == 3) %>%
  ggplot() +
  geom_abline(slope=1) +
  geom_point(aes(mean_abund, mean_pred, col = family_names), cex =3)+
  facet_wrap(~mod_ID, scale = "free")+
  main_theme

recap_pred_bin_df %>%
  filter(mod_ID == 3) %>%
  ggplot() +
  geom_point(aes(family_names, AUC),cex = 3, alpha =0.8) +
  main_theme
```
#### AUC-ROC curve at family level and 

```{r, purl = FALSE}
compute.ROC <- function(observed, predicted, pred_name){
  df_roc_AUC = data.frame(threshold =  sort(unique(predicted)),
                        pred_name = pred_name,
                        precision = NA,
                        TPR = NA,
                        FPR = NA,
                        F1_score = NA)

  for (n in 1:nrow(df_roc_AUC)){
    threshold <- df_roc_AUC[n,1]
    temp_pred <- predicted > threshold

  
    TP <- sum(observed & temp_pred) # Correct positive guesses
    TN <- sum(!(observed | temp_pred)) # Correct negative guesses
    FP <- sum(!observed & temp_pred) # Absence in observe but presence predicted (False positive guesses)
    FN <- sum(observed & !temp_pred) # Presence in observe but absence predicted (False negative guesses)
    
    
    precision <- TP/(TP+FP) # Correct positive guesses / all positive guesses (How precise is the positive section)
    TPR <- TP/(TP+FN) # Correct positive guesses / all true presence (How well the positives are selected)
    FPR <- FP/(FP+TN) # False positive guesses / all true absence (How bad the negatives are selected)
    
    df_roc_AUC[n,"precision"] <- precision
    df_roc_AUC[n,"TPR"] <- TPR
    df_roc_AUC[n,"FPR"] <- FPR
    df_roc_AUC[n,"F1_score"] <- 2*(precision*TPR)/(precision + TPR)
    
    
  }
  return(df_roc_AUC)
}
```

```{r, purl = FALSE}

1:ncol(list_mods_bin_crossvalidation[[1]]$m_converg$Y) %>%
  map(\(x) compute.ROC(observed =  list_mods_bin_crossvalidation[[3]]$m_converg$Y[,x], predicted = list_mods_bin_crossvalidation[[3]]$mPredY[,x],
            pred_name = colnames(list_mods_bin_crossvalidation[[3]]$m_converg$Y)[x])) %>%
    bind_rows() -> ROC_df


ROC_df %>%
  group_by(pred_name) %>%
  filter(F1_score == max(F1_score, na.rm = TRUE)) %>%
  select(pred_name, threshold, F1_score) %>%
  distinct() %>%
  mutate(threshold = case_when(pred_name %in% c("Glomeraceae (452 OTU)", "Acaulosporaceae (88 OTU)") ~ 1.1,
                   .default = threshold)) -> max_f1_score_df
ROC_df %>%
  mutate(balanced_score = TPR-FPR) %>%
  group_by(pred_name) %>%
  filter(balanced_score == max(balanced_score, na.rm = TRUE)) %>%
  select(pred_name, threshold, balanced_score, TPR, FPR) %>%
  rename(TPR_b = "TPR", FPR_b = "FPR") %>%
  distinct() %>%
  rbind(.,data.frame(pred_name =  c("Glomeraceae (452 OTU)", "Acaulosporaceae (88 OTU)"), threshold = 1.1, balanced_score =NA)) -> balanced_score_df


ROC_df %>%
  left_join(balanced_score_df %>%
                rename(threshold_B = "threshold"), by ="pred_name") %>%
  left_join(max_f1_score_df %>%
              dplyr::select(!F1_score) %>%
              rename(threshold_F1 = "threshold"), by ="pred_name") %>%
  ggplot()+
  facet_wrap(~pred_name) +
  geom_line(aes(x=threshold,y=F1_score), size=1) +
  geom_vline(aes(xintercept=threshold_B), col = "blue")+
  geom_vline(aes(xintercept=threshold_F1), col = "red")+
  coord_cartesian(xlim = c(0,1), ylim=c(0,1.01), expand = FALSE) +
  labs(x='threshold', y='F1 score') +
  main_theme
ROC_df %>%
  left_join(balanced_score_df %>%
              rename(threshold_B = "threshold"), by ="pred_name") %>%
  left_join(max_f1_score_df %>%
              dplyr::select(!F1_score) %>%
              rename(threshold_F1 = "threshold"), by ="pred_name") %>%
  arrange(threshold) %>%
  ggplot() +
  facet_wrap(~pred_name) +
  geom_path(aes(x=FPR,y=TPR), size=1) +
  geom_ribbon(aes(x=FPR,ymin=0,ymax=TPR),
              alpha=0.2) +
  geom_vline(aes(xintercept = FPR_b), col = "blue", linetype = 2, linewidth =  1.5)+
  geom_hline(aes(yintercept = TPR_b), col = "blue", linetype = 2, linewidth =  1.5)+
  #geom_vline(aes(xintercept=threshold_F1), col = "red")+
  coord_cartesian(xlim = c(0,1), ylim=c(0,1.01), expand = FALSE) +
  geom_abline( linetype='dashed') +
  labs(x='False Positive Rate \n (False presence predicted / all true absence)', y='True Positive Rate \n(True presence predicted / all true presence)',
       title = 'ROC curve of the model')+
  main_theme

balanced_score_df
max_f1_score_df  
```

#### Hurdel model RMSE

```{r, purl = FALSE}

str(balanced_score_df)
pred_order <- colnames(list_mods_bin_crossvalidation[[2]]$mPredY)

balanced_score_df %>%
  mutate(pred_name = factor(pred_name, levels = pred_order)) %>%
  arrange(pred_name) -> balanced_score_df



absence_mat <- sweep(list_mods_bin_crossvalidation[[2]]$mPredY, 2,
                       balanced_score_df$threshold, 
                       FUN = function(x, th) x > th)
```

```{r, purl = FALSE}
compute.RMSE.hurdel <- function(pred_mat_model_trucated, absence_mat = NA, Y_family = Y_family, mod_scale = "none", 
                                truncated_model_ID = "NA",  occurance_model_ID = "NA"){
   
  mPredY_hurdel <- pred_mat_model_trucated
  
  if(occurance_model_ID != "NA"){
    mPredY_hurdel[absence_mat] <- 0
  }
   
  mPredY_hurdel %>%
      as.data.frame() %>%
      rownames_to_column("Sample_code") %>%
      pivot_longer(-Sample_code, names_to = "family_names", values_to = "pred_abund") %>%
    mutate(pred_abund = case_when(mod_scale == "log1p" ~ exp(pred_abund)-1,
                            .default = pred_abund),
           pred_abund = case_when(mod_scale == "log" ~ exp(pred_abund),
                            .default = pred_abund))-> hurdel_long
  
  Y_family %>%
    as.data.frame() %>%
    rownames_to_column("Sample_code") %>%
    pivot_longer(-Sample_code, names_to = "family_names", values_to = "true_abund") -> true_value_long
  
  hurdel_long %>%
    left_join(true_value_long, by = join_by(family_names,Sample_code)) %>%
    mutate( mod_ID = str_c(truncated_model_ID,"_",occurance_model_ID)) -> abund_test_df
    return(abund_test_df)
}


```


```{r, purl = FALSE}
list_truncated_model_ID <- list("lognorm_null_trunc",
  "lognorm_full_trunc",
  "lognorm_poly_trunc",
  "pois_trunc_null",
  "pois_trunc_full",
  "pois_trunc_poly",
  "pois_null_log",
  "pois_full_log", #8
  "pois_poly_log",
  "pois_null_trunc_log",
  "pois_full_trunc_log",
  "pois_poly_trunc_log",
  "lognorm_null",
  "lognorm_full",
  "lognorm_poly",
  "lognorm_null_log",
  "lognorm_full_log",
  "lognorm_poly_log"
  )

list_occurance_model_ID = c(rep("Bin",6),
                            rep("NA",3),
                            rep("Bin",3),
                            rep("NA",6))

list_mod_scale = c(rep("none",6),
                   rep("log1p",3),
                   rep("log",3),
                   rep("none",3),
                   rep("log1p",3))
x= 3
1:length(list_mods_crossvalidation) %>%
 map(\(x) compute.RMSE.hurdel(pred_mat_model_trucated = list_mods_crossvalidation[[x]]$mPredY,
                    absence_mat = absence_mat,
                    Y_family = Y_family,
                    mod_scale = list_mod_scale[x],
                    truncated_model_ID = list_truncated_model_ID[x],
                    occurance_model_ID = list_occurance_model_ID[x])
     ) %>%
  bind_rows() -> allcomplet_crossvalidation_df
                    
```

```{r}
#"Unknown Gigasporales (6 OTU)",
allcomplet_crossvalidation_df %>%
   filter( !(family_names %in% c("Glomeraceae (452 OTU)", "Acaulosporaceae (88 OTU)",family_names != "Unknown Gigasporales (6 OTU)", "Pervetustaceae (2 OTU)")))%>%
  ggplot()+
  facet_wrap(~mod_ID, scale = "free")+
  geom_point(aes(true_abund,pred_abund)) +
  geom_smooth(aes(true_abund, pred_abund), method = "lm") +
  geom_abline(slope=1) +
  labs(x= "Observed abundances", y = "Predicted abudances") +
  scale_x_log10() +
  scale_y_log10() +
  main_theme
allcomplet_crossvalidation_df$mod_ID %>% unique
allcomplet_crossvalidation_df %>%
  filter( mod_ID == "pois_trunc_poly_Bin")%>%
  ggplot()+
  facet_wrap(~family_names, scale = "free")+
  geom_point(aes(true_abund,pred_abund)) +
  geom_smooth(aes(true_abund, pred_abund), method = "lm") +
  geom_abline(slope=1) +
  labs(x= "Observed abundances", y = "Predicted abudances") +
  scale_x_log10() +
  scale_y_log10() +
  main_theme

allcomplet_crossvalidation_df %>%
 filter(str_detect(mod_ID, "_log_")) %>%
  ggplot()+

  geom_point(aes(true_abund,pred_abund, col = family_names), cex = 4, alpha = 0.6) +
  facet_wrap(~mod_ID, scale ="free")+
    #facet_grid(col = vars(family_names), row = vars(mod_ID), scale  = "free") +
  geom_abline(slope=1) +
  labs(x= "Observed abundances", y = "Predicted abudances")+
  scale_x_log10() +
  scale_y_log10() +
  scale_color_viridis(discrete = T) +
  main_theme
```

```{r}
mods_crossvalidation_df %>%
   #filter( !(family_names %in% c("Glomeraceae (452 OTU)", "Acaulosporaceae (88 OTU)")))%>%
  ggplot()+
  facet_wrap(~mod_ID, scale = "free")+
  geom_point(aes(true_abund,pred_abund)) +
  geom_smooth(aes(true_abund, pred_abund), method = "lm") +
  geom_abline(slope=1) +
  labs(x= "Observed abundances", y = "Predicted abudances") +
  scale_x_log10() +
  scale_y_log10() +
  main_theme
```


```{r}
allcomplet_crossvalidation_df %>%
  mutate(diff = true_abund - pred_abund) %>%
  group_by(family_names,mod_ID) %>%
  summarise(n = n(),
            median_abund = median(true_abund, na.rm = T),
            mean_pred_abund = mean(pred_abund, na.rm = T),
            mean_abund = mean(true_abund, na.rm = T),
            sd_abund = sd(true_abund, na.rm = T),
            RMSE = sqrt(sum(diff**2)/n),
            ratio_RMSE_sd = (RMSE)/sd_abund,
            mod_ID = unique(mod_ID)) -> allcomplet_model_recap

allcomplet_model_recap %>%
  filter(str_detect(mod_ID, "_log_")) %>%
  ggplot() +
  facet_wrap(~mod_ID, scale = "free") +
  geom_point(aes(family_names, RMSE), cex = 4) +
  scale_y_log10() +
  scale_color_viridis(discrete = T) +
  main_theme_final

allcomplet_model_recap %>%
  filter(str_detect(mod_ID, "_log_")) %>%
  ggplot() +
  facet_wrap(~mod_ID, scale = "free") +
  geom_point(aes(mean_abund, mean_pred_abund), cex = 4) +
  scale_y_log10() +
  scale_x_log10() +
  scale_color_viridis(discrete = T) +
  main_theme

allcomplet_model_recap %>%
  group_by(mod_ID) %>%
  summarise(mean_RMSE = mean(RMSE)) %>%
  arrange(mean_RMSE)

```

```{r}
mods_crossvalidation_df %>%
  filter( mod_ID == "pois_full_log")%>%
  ggplot()+
  facet_wrap(~family_names)+
  geom_point(aes(true_abund,pred_abund)) +
  geom_smooth(aes(true_abund, pred_abund), method = "lm") +
  geom_abline(slope=1) +
  labs(x= "Observed abundances", y = "Predicted abudances") +
  scale_x_log10() +
  scale_y_log10() +
  main_theme

mods_crossvalidation_df %>%
  filter( mod_ID == "pois_full_log")%>%
  ggplot()+
  geom_point(aes(true_abund,pred_abund)) +
  geom_smooth(aes(true_abund, pred_abund), method = "lm") +
  geom_abline(slope=1) +
  labs(x= "Observed abundances", y = "Predicted abudances") +
  scale_x_log10() +
  scale_y_log10() +
  main_theme

mods_crossvalidation_df %>%
  filter( mod_ID == "pois_null_trunc_log")%>%
  ggplot()+
  facet_wrap(~family_names)+
  geom_point(aes(true_abund,pred_abund)) +
  geom_smooth(aes(true_abund, pred_abund), method = "lm") +
  geom_abline(slope=1) +
  labs(x= "Observed abundances", y = "Predicted abudances") +
  scale_x_log10() +
  scale_y_log10() +
  main_theme

mods_crossvalidation_df %>%
  filter( mod_ID == "pois_null_log")%>%
  ggplot()+
  geom_point(aes(true_abund,pred_abund)) +
  geom_smooth(aes(true_abund, pred_abund), method = "lm") +
  geom_abline(slope=1) +
  labs(x= "Observed abundances", y = "Predicted abudances") +
  scale_x_log10() +
  scale_y_log10() +
  main_theme
```


## Models results
### Convergence

```{r include=FALSE, purl = FALSE}
list_mods_crossvalidation[[8]]$m_converg -> m_converg_selected # pois_full_log_NA
postBeta2 <- getPostEstimate(m_converg_selected, parName = "Beta")
beta_results <- postBeta2$mean
mpost2 <- convertToCodaObject(m_converg_selected)
gelman.diag(mpost2$Beta, multivariate = FALSE) -> gelman_diag_df2
gelman_diag_df2$psrf

beta_results <- postBeta2$mean
rownames(beta_results) <- colnames(m_converg_selected$X)
beta_results <- beta_results * ((postBeta2$support > 0.9) + (postBeta2$support < (1 - 0.9)) > 0)
beta_results <- t(beta_results)[family_tree_filter$tip.label, colnames(m_converg_selected$X)]
#colnames(beta_results) <- c("Intercept","NDVI", "Rain", "tmin", "tdelta", "wind") #  "Cluster B", "Cluster C", "Cluster E", "LD Medium", "LD High", 
```

```{r include=FALSE, purl = FALSE}
list_mods_bin_crossvalidation[[2]]$m_converg -> m_converg_selected_bin
postBeta2_bin <- getPostEstimate(m_converg_selected_bin, parName = "Beta")
beta_results_bin <- postBeta2_bin$mean
mpost2_bin <- convertToCodaObject(m_converg_selected_bin)
gelman.diag(mpost2_bin$Beta, multivariate = FALSE) -> gelman_diag_bin_df2
gelman_diag_bin_df2$psrf

beta_results_bin <- postBeta2_bin$mean
rownames(beta_results_bin) <- colnames(m_converg_selected_bin$X)
beta_results_bin <- beta_results_bin * ((postBeta2_bin$support > 0.9) + (postBeta2_bin$support < (1 - 0.9)) > 0)
beta_results_bin <- t(beta_results_bin)[family_tree_filter$tip.label, colnames(m_converg_selected_bin$X)]
#colnames(beta_results) <- c("Intercept","NDVI", "Rain", "tmin", "tdelta", "wind") #  "Cluster B", "Cluster C", "Cluster E", "LD Medium", "LD High", 
```
### family response to each varaibles

Estimated response of each family to environmental variable with phylogenetic tree. 

Response of abundance :

```{r echo=FALSE, purl = FALSE}
library(ggtree)
p <- ggtree(family_tree_filter, layout = "roundrect") +
  geom_tiplab(align = TRUE) +
  theme_tree()

gheatmap(p, beta_results, offset = 1, width = 1, font.size = 5,
         colnames_angle = -60, hjust = 0) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", na.value = "grey90",
                       limits = c(min(beta_results), max(beta_results))) +
  scale_y_continuous(expand = c(0, 5)) +
  labs(fill = "Parameters\nvalues")
```

```{r echo=FALSE, purl = FALSE}
library(ggtree)
p <- ggtree(family_tree_filter, layout = "roundrect") +
  geom_tiplab(align = TRUE) +
  theme_tree()

gheatmap(p, beta_results_bin, offset = 1, width = 1, font.size = 5,
         colnames_angle = -60, hjust = 0) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", na.value = "grey90",
                       limits = c(min(beta_results_bin), max(beta_results_bin))) +
  scale_y_continuous(expand = c(0, 5)) +
  labs(fill = "Parameters\nvalues", titl=" Occurence model")
```

### Phylogenetic signal

Abundances : 

```{r echo=FALSE, purl = FALSE}
gelman.diag(mpost2$Rho)$psrf
summary(mpost2$Rho)
```

```{r include=FALSE, purl = FALSE}
library(nlme)
library(purrr)
# ------------------------------------------------------------------
# Compute Pagel's lambda for each covariate via nlme gls + corPagel
# ------------------------------------------------------------------
models <- list(abund = m_converg) # , bin = m_converg_bin

compute.padgel.lambda <- function(models, i) {
  m <- models[[i]]
  postBeta <- getPostEstimate(m, parName = "Beta")
  phyloTree <- m$phyloTree
  nc <- dim(postBeta$mean)[1]

  results <- matrix(NA, nrow = nrow(postBeta$mean), ncol = 4) %>%
    as.data.frame() %>%
    rename(lambda = "V1", p_value = "V2", model = "V3", covariate = "V4")

  control <- glsControl(opt = "optim", msVerbose = TRUE)

  for (j in 1:nc) {
    y <- postBeta$mean[j, ]
    m1 <- gls(y ~ 1)
    m2 <- gls(y ~ 1, correlation = corPagel(0.5, phyloTree, fixed = FALSE, form = ~names(y)), control = control)
    z1 <- summary(m2)
    z2 <- anova(m1, m2)
    lambda <- z1$modelStruct[1]$corStruct
    pvalue <- z2$`p-value`[2]

    results$p_value[j] <- pvalue
    results$lambda[j] <- lambda
    results$model[j] <- i
    results$covariate[j] <- colnames(m$X)[j]
  }
  return(results)
}

any(branching.times(family_tree_filter) == 0)

c("abund") %>%#, "bin"
  purrr::map(\(x) compute.padgel.lambda(models, x)) %>%
  list_rbind() -> lambda_df


```


```{r echo=FALSE, purl = FALSE}
lambda_df %>%
  knitr::kable()
```

Lambda is a metric that characterize phylogenetic signal. Here we characterize how response is related to phylogeny. When Lambda is close to 1 closely related species will have the same responses to environmental variable. When Lambda is close to 0 responses to environmental variables are random across the phylogeny. Here some reponses of occurrences and abundances are strongly phylogenically structure.

Some reference for this metric : 

https://doi.org/10.1111/j.2041-210X.2012.00196.x

https://doi.org/10.1111/1365-2745.13839

```{r echo=FALSE, purl = FALSE}
lambda_df %>%
  ggplot() +
    geom_point(aes(lambda, covariate,colour = model, alpha = p_value <= 0.05), cex = 4) +
  geom_vline(xintercept = 0, linetype = 2) +
  geom_vline(xintercept = 1,linetype = 2) +
  scale_color_viridis(discrete = T)+
  main_theme_final
```


### Variance partitonning

Variance explain by each variables for each family


abundances: 

```{r echo=FALSE, warning=FALSE, purl = FALSE}
VP2 <- computeVariancePartitioning(m_converg_selected, na.ignore = TRUE)


VP2$vals %>%
  as.data.frame() %>%
  rownames_to_column("var") %>%
  mutate(var = factor(var, levels = c("ndvi", "precip", "tmax", "tdelta", "wind", "Random: sample"))) %>%
  pivot_longer(-var) %>%
  ggplot() +
  geom_col(aes(x = name, y = value, fill = var)) +
  theme_classic() +
  theme(
    axis.title.y = element_blank(),
    axis.text.x = element_text(colour = "black", size = 9, face = "italic", angle = 45, vjust = 1, hjust = 1),
    axis.text.y = element_text(colour = "black", size = 13, face = "italic"),
    axis.title = element_text(colour = "black", size = 16),
    panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
    legend.title = element_text(colour = "black", size = 16, hjust = 0.5),
    legend.text = element_text(colour = "black", size = 13)
  ) +
  ggsci::scale_fill_simpsons()

```

```{r echo=FALSE, warning=FALSE, purl = FALSE}
VP2_bin <- computeVariancePartitioning(m_converg_selected_bin, na.ignore = TRUE)


VP2_bin$vals %>%
  as.data.frame() %>%
  rownames_to_column("var") %>%
  mutate(var = factor(var, levels = c("ndvi", "precip", "tmax", "tdelta", "wind", "Random: sample"))) %>%
  pivot_longer(-var) %>%
  ggplot() +
  geom_col(aes(x = name, y = value, fill = var)) +
  labs(x ="Families", y = "Variance partionning", fill = "Covariates") +
  ggsci::scale_fill_simpsons() +
  main_theme_final+
  theme( axis.text.x = element_text(colour = "black", size=7,angle=45, face="italic", vjust =1, hjust =1))-> 
ggsave(plot = variance_partionning_occurence, filename = "figures/variance_partionning_occurence.svg", units = "cm", width = 9 ,height = 16)

variance_partionning_occurence
```
### Residuals correlation matrix

Correlation between each family when all the environmental variable have been accounted for.

Those figures show unexplained correlation caused by omitted biotic or abiotic variables

Abundances :

```{r echo=FALSE, purl = FALSE}
library(corrplot)

OmegaCor <- computeAssociations(m_converg_selected)
supportLevel <- 0.95
toPlot <- ((OmegaCor[[1]]$support > supportLevel) + (OmegaCor[[1]]$support < (1 - supportLevel)) > 0) * OmegaCor[[1]]$mean

corrplot(toPlot, method = "color", col = colorRampPalette(c("blue", "white", "red"))(200),
         tl.cex = 0.6, tl.col = "black",
         title = paste("random effect level:", m_converg_selected$rLNames[1]),
         mar = c(0, 0, 1, 0), order = "hclust")
```

```{r echo=FALSE, purl = FALSE}

ndvi_raster_df <- rasterToPoints(ndvi_uganda) %>%
  as.data.frame() %>%
  rename(ndvi = "ndvi_uganda_lower_res")

precip_raster_df <- rasterToPoints(precip_uganda_resampled) %>%
  as.data.frame() %>%
  rename(precip = "precip_2023_lower_res")

tmax_raster_df <- rasterToPoints(tmax_uganda_resampled) %>%
  as.data.frame() %>%
  rename(tmax = "tmax_2023_lower_res")

tdelta_raster_df <- rasterToPoints(delta_t_uganda) %>%
  as.data.frame() %>%
  rename(tdelta = "layer")

wind_raster_df <- rasterToPoints(wind_2023) %>%
  as.data.frame() %>%
  rename(wind = "wind_2023")

data_spatial_df <- ndvi_raster_df %>%
  left_join(precip_raster_df, by = join_by("x", "y")) %>%
  left_join(tmax_raster_df, by = join_by("x", "y")) %>%
  left_join(tdelta_raster_df, by = join_by("x", "y")) %>%
  left_join(wind_raster_df, by = join_by("x", "y")) %>% 
  na.omit()%>%
  mutate(across(c(ndvi, precip, tmax, tdelta, wind), ~vegan::decostand(.x, method = "standardize")[,1]))
```

# Occurence

```{r, purl = FALSE}
data_spatial_df %>%
  pivot_longer(-c(x,y)) %>%
  ggplot() +
  facet_wrap(~name, scale = "free") +
  geom_raster(aes(x, y, fill = value))

# Prepare grid for gradient predictions
xy.grid <- data_spatial_df %>%
  dplyr::select(x, y) %>%
  as.matrix()

XData.grid <- data_spatial_df %>%
  dplyr::select(-c(x, y))

Gradient <-  prepareGradient(list_mods_bin_crossvalidation[[2]]$hmsc_mod, XDataNew = XData.grid, sDataNew = list(route = xy.grid))
predY_bin <- stats::predict(m_converg_selected_bin, Gradient = Gradient)

EpredY_bin_map <- predY_bin[[1]]

str(predY_bin)
# Average over predictions
if (length(predY_bin) > 1) {
  for (i in 2:length(predY_bin)) {
    EpredY_bin_map <- EpredY_bin_map + predY_bin[[i]]
    if (i %% 1000 == 0) print(i)
  }
  EpredY_bin_map <- EpredY_bin_map / length(predY_bin)
}
```

```{r}
ROC_df %>%
  left_join(balanced_score_df %>%
              rename(threshold_B = "threshold"), by ="pred_name") %>%
  left_join(max_f1_score_df %>%
              dplyr::select(!F1_score) %>%
              rename(threshold_F1 = "threshold"), by ="pred_name") %>%
  arrange(threshold) %>%
  ggplot() +
  facet_wrap(~pred_name) +
  geom_path(aes(x=FPR,y=TPR), size=1) +
  geom_ribbon(aes(x=FPR,ymin=0,ymax=TPR),
              alpha=0.2) +
  geom_vline(aes(xintercept = FPR_b), col = "blue", linetype = 2, linewidth =  1.5)+
  geom_hline(aes(yintercept = TPR_b), col = "blue", linetype = 2, linewidth =  1.5)+
  #geom_vline(aes(xintercept=threshold_F1), col = "red")+
  coord_cartesian(xlim = c(0,1), ylim=c(0,1.01), expand = FALSE) +
  geom_abline( linetype='dashed') +
  labs(x='False Positive Rate \n (False presence predicted / all true absence)', y='True Positive Rate \n(True presence predicted / all true presence)',
       title = 'ROC curve of the model')+
  main_theme

recap_pred_bin_df %>%
  filter(mod_ID == 2, AUC >0.75| is.na(AUC)) %>% #, family_names!="Diversisporaceae (36 OTU)"
  pull(family_names) -> good_occurence_prediction
```

```{r, purl = FALSE}

balanced_score_df
balanced_score_df$pred_name == colnames(EpredY_bin_map)
EpredY_occurance_map <- sweep(EpredY_bin_map, 2,
                       balanced_score_df$threshold, 
                     FUN = function(x, th) x < th)
EpredY_occurance_map <- +EpredY_occurance_map
```


```{r}
library(ggspatial)  # fonctions annotation_map_tile
```


```{r, purl = FALSE}
str(EpredY_occurance_map)
data_spatial_df %>%
    bind_cols(EpredY_occurance_map) %>%
    pivot_longer(-c(x, y, ndvi, precip, tmax, tdelta, wind)) %>%
    mutate(value = value) %>%
    ggplot() +
    facet_wrap(~name) +
    geom_raster(aes(x, y, fill = value)) +
    scale_fill_viridis( option = "viridis") +
    labs(x = "Lon", y = "Lat", fill = "Occurence") +
    theme_classic() +
    theme(
      aspect.ratio = 1,
      plot.margin = margin(0, 0, 0, 0),
      axis.title.x = element_blank(),
      panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
      axis.title.y = element_text(colour = "black", size = 14, face = "italic")
    )

data_spatial_df %>%
    bind_cols(EpredY_occurance_map) %>%
    pivot_longer(-c(x, y, ndvi, precip, tmax, tdelta, wind)) %>%
    filter(name %in% good_occurence_prediction) %>%
    mutate(value = as.factor(value)) %>%
    ggplot() +
    facet_wrap(~name) +
    geom_raster(aes(x, y, fill = value)) +
    scale_fill_viridis(discrete = T, option = "viridis", begin = 0.05, end = 0.6) +
    labs(x = "Lon", y = "Lat", fill = "Occurence") +
    theme_classic() +
    theme(
      aspect.ratio = 1,
      plot.margin = margin(0, 0, 0, 0),
      axis.title.x = element_blank(),
      panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
      axis.title.y = element_text(colour = "black", size = 14, face = "italic")
    ) -> map_occurence_best_predicted_family

data_spatial_df %>%
    bind_cols(data.frame(richness= rowSums(EpredY_occurance_map))) %>%

    pivot_longer(-c(x, y, ndvi, precip, tmax, tdelta, wind)) %>%

    mutate(value = value) %>%
    ggplot() +
    #facet_wrap(~name) +
    geom_raster(aes(x, y, fill = value)) +
    annotation_north_arrow(
      location = "tr", 
      which_north = "true", 
      height = unit(1, "cm"), 
      width  = unit(1, "cm"),
      style = north_arrow_minimal(
        line_col = "black",   # outline color
        fill     = "black",
        text_col = "black",
        line_width = 2, 
        text_size  = 10 
      )) +
    scale_fill_viridis(option = "magma") +
    labs(x = "Longitude", y = "Latitude", fill = "Family richness") + 
    main_theme_final -> map_richness

map_occurence_best_predicted_family
map_richness


ggsave(plot = map_richness, filename = "figures/map_richness.svg", units = "cm", width = 11 ,height = 20)
ggsave(plot = map_occurence_best_predicted_family, filename = "figures/map_occurence_best_predicted_family.svg", units = "cm", width = 33 ,height = 20 )
```

# Abundance

```{r, purl = FALSE}

data_spatial_df %>%
  pivot_longer(-c(x,y)) %>%
  ggplot() +
  facet_wrap(~name, scale = "free") +
  geom_raster(aes(x, y, fill = value))

# Prepare grid for gradient predictions
xy.grid <- data_spatial_df %>%
  dplyr::select(x, y) %>%
  as.matrix()

XData.grid <- data_spatial_df %>%
  dplyr::select(-c(x, y))

Gradient <-  prepareGradient(list_mods_crossvalidation[[8]]$hmsc_mod, XDataNew = XData.grid, sDataNew = list(route = xy.grid))
predY <- stats::predict(m_converg_selected, Gradient = Gradient)

EpredY_map <- predY[[1]]

str(predY)
# Average over predictions
if (length(predY) > 1) {
  for (i in 2:length(predY)) {
    EpredY_map <- EpredY_map + predY[[i]]
    if (i %% 1000 == 0) print(i)
  }
  EpredY_map <- EpredY_map / length(predY)
}
```



```{r, purl = FALSE}
summary(EpredY_map)
data_spatial_df %>%
    bind_cols(EpredY_map) %>%
    pivot_longer(-c(x, y, ndvi, precip, tmax, tdelta, wind)) %>%
    filter(!(name %in% c("Unknown Archaeosporomycetes (4 OTU)",
                       "Unknown cl01 (27 OTU)",
                       "Unknown Glomeromycota (6 OTU)",
                       "Glomeraceae (452 OTU)"))) %>%
    mutate(value = value) %>%
    ggplot() +
    facet_wrap(~name) +
    geom_raster(aes(x, y, fill = value)) +
    scale_fill_viridis(option = "magma") +
    labs(x = "Lon", y = "Lat", fill = "Abundance (log10)") +
    theme_classic() +
    theme(
      aspect.ratio = 1,
      plot.margin = margin(0, 0, 0, 0),
      axis.title.x = element_blank(),
      panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
      axis.title.y = element_text(colour = "black", size = 14, face = "italic")
    )
data_spatial_df %>%
    bind_cols(EpredY_map) %>%
    pivot_longer(-c(x, y, ndvi, precip, tmax, tdelta, wind)) %>%
    filter(!(name %in% c("Unknown Archaeosporomycetes (4 OTU)",
                       "Unknown cl01 (27 OTU)",
                       "Unknown Glomeromycota (6 OTU)",
                       "Glomeraceae (452 OTU)",
                       "Acaulosporaceae (88 OTU)"))) %>%
    mutate(value = value) %>%
    ggplot() +
    facet_wrap(~name) +
    geom_raster(aes(x, y, fill = value)) +
    scale_fill_viridis(option = "magma") +
    labs(x = "Lon", y = "Lat", fill = "Abundance (log10)") +
    theme_classic() +
    theme(
      aspect.ratio = 1,
      plot.margin = margin(0, 0, 0, 0),
      axis.title.x = element_blank(),
      panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
      axis.title.y = element_text(colour = "black", size = 14, face = "italic")
    )

```


