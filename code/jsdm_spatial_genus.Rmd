---
title: "Untitled"
output: html_document
date: "2025-08-08"
---

```{r include=FALSE}
library(tidyverse)
library(raster)
library(mapview)
library(leaflet)
library(leafem)
library(rasterVis)
library(readxl)
library(sf)
library(pals)

library(Hmsc)
library(ape)
```
# Spatial covariate

## Sampling points
```{r echo=FALSE}
metadata <- read_xlsx(path = "data/Metadata_Doreen_070525.xlsx")

utm_coords <- metadata %>%
  mutate(
    zone = as.numeric(substr(easting, 1, 2)),
    band = substr(easting, 3, 3),
    easting = as.numeric(sub(".* ", "", easting)),
    northing = as.numeric(northing),

    hemisphere = ifelse(band == "N", "north", "south") # M = South Hemisphere
  )

# Function to convert a single row to lat/lon
convert_to_wgs84 <- function(zone, hemisphere, easting, northing,Sample_code) {
  epsg <- if (hemisphere == "north") {
    32600 + zone  # Northern hemisphere UTM EPSG codes
  } else {
    32700 + zone  # Southern hemisphere UTM EPSG codes
  }

  point <- st_sfc(st_point(c(easting, northing)), crs = epsg)
  point_wgs84 <- st_transform(point, crs = 4326)
  coords <- st_coordinates(point_wgs84)
  tibble( lon = coords[1], lat = coords[2],Sample_code = Sample_code)
}
utm_coords %>%
  mutate(zone = case_when(zone==32~ 36,
                             .default = zone),
          northing = case_when(Sample_code == "N17" ~ 86562,
                             .default = northing)) -> utm_coords
# Apply to each row
wgs84_coords <- pmap_dfr(utm_coords[, c("zone", "hemisphere", "easting", "northing","Sample_code")], convert_to_wgs84) %>%
  left_join(metadata, by = "Sample_code") %>%
  st_as_sf(coords = c("lon", "lat"),crs = 4326) %>%
  mutate(
     lon= st_coordinates(.)[,1],
     lat= st_coordinates(.)[,2]
  )


leaflet() %>% 
  addTiles() %>%
  addMarkers(data=wgs84_coords,~lon, ~lat, popup = ~paste(round(lat,2), round(lon,2)) , label = ~Sample_code)%>%
  addCircleMarkers(data = wgs84_coords, lng = ~lon,
                  lat = ~lat, radius = 8, color = "blue", fillOpacity = 0.8)
```

## Land degradation

This metric come from : https://gmesgeoportal.rcmrd.org/maps/8005edb1d35249e89f52260971c11c8b/about
key parameters used include: soil erosivity, slope, rainfall intensity, population and land cover

```{r echo=FALSE}
land_degradation_raster <- raster("outputs/raster/land_degradation_reclassify.tif")
land_degradation_type <- levels(land_degradation_raster)[[1]]
land_degradation_type <- land_degradation_type %>%
  mutate(land_degra = factor(land_degra, levels = c("Low", "Medium", "High")))
land_degradation_df <- raster::extract(land_degradation_raster,  wgs84_coords)%>%
  tibble(ID = .,
  Sample_code  = wgs84_coords$Sample_code)%>%
  left_join(land_degradation_type,  by = "ID")

myPal1 <- rev(RColorBrewer::brewer.pal('PRGn', n=3))


leaflet() %>%
  addTiles() %>% 
  addRasterImage(land_degradation_raster, opacity = 0.7,
                 color = myPal1) %>%
   addLegend(
    "bottomright",
    pal = colorFactor(palette=myPal1, domain = land_degradation_type$land_degra),
    values = land_degradation_type$land_degra,
    title = "Land Degradation"
  )
```

## Land cover

This land cover metric is not ideal. Most of the sampling point fall in *Subsistence Cropland* (cf. 4 map below), leading to not enough replication of some land cover class for the model. We will probably replace this raster by agro-ecological zone one

```{r echo=FALSE}
land_cover_raster <- raster("outputs/raster/land_cover_lower_res.tif")

land_cover_type <- levels(land_cover_raster)[[1]] %>%
  dplyr::select(ID,Land_Cover) %>%
  mutate(Land_Cover = factor(Land_Cover, levels = levels(land_cover_raster)[[1]]$Land_Cover))


land_cover_df <- raster::extract(land_cover_raster, wgs84_coords) %>%
 tibble(ID = .,
    Sample_code  = wgs84_coords$Sample_code) %>%
    left_join(land_cover_type, by = "ID")

myPal2 <- pals::stepped2(n=18)

pal_land_cover <- colorFactor(myPal2[unique(land_cover_df$ID)], 
                   domain = wgs84_coords$Land_Cover)
leaflet() %>%
  addTiles() %>% 
  addRasterImage(land_cover_raster, opacity = 0.7,
                 colors = myPal2) %>%
  addLegend(
    "bottomright",
    pal = colorFactor(palette=myPal2, domain = land_cover_type$Land_Cover),
    values =land_cover_type$Land_Cover,
    title = "Land Cover"
  )
```
## Cluster agroecologique

```{r}
cluster_agro_raster <- raster("outputs/raster/cluster_agro_lower_res.tif")
cluster_agro_type <- levels(cluster_agro_raster)[[1]] %>%
  dplyr::select(ID, Cluster) %>%
  mutate(Cluster = factor(Cluster, levels = levels(cluster_agro_raster)[[1]]$Cluster))

cluster_agro_df <- raster::extract(cluster_agro_raster, wgs84_coords) %>%
  tibble(ID = ., Sample_code = wgs84_coords$Sample_code) %>%
  left_join(cluster_agro_type, by = "ID")

myPal3 <- ggsci::pal_simpsons()(8)

leaflet() %>%
  addTiles() %>%
  addRasterImage(cluster_agro_raster, opacity = 0.7, colors = myPal3) %>%
  addLegend(
    "bottomright",
    pal = colorFactor(palette = myPal3, domain = cluster_agro_type$Cluster),
    values = cluster_agro_type$Cluster,
    title = "Land Cover"
  )
```


## NDVI

Indice for vegetation quantity 


https://planetarycomputer.microsoft.com/dataset/sentinel-3-synergy-v10-l2-netcdf

```{r echo=FALSE}
ndvi_uganda <- raster("outputs/raster/ndvi_uganda_lower_res.tif")

ndvi_df <- raster::extract(ndvi_uganda, wgs84_coords)%>%
 tibble(ndvi = .,
    Sample_code  = wgs84_coords$Sample_code)

pal_ndvi <- colorNumeric("viridis", domain = c(0, 1))
leaflet() %>%
  addTiles() %>% 
  addRasterImage(ndvi_uganda, opacity = 0.7) %>%
  addLegend(
    "bottomright",
    pal = pal_ndvi,
    values = c(0, 1),
  )
```

## Precipitation

This is still work in progess, here the precipitation are for only **May 2023**. It is hard to get the data but I will try to obtain mean or sum precipitation for a hole year before June 2023.

```{r echo=FALSE}
precip_uganda_resampled <- raster("outputs/raster/precip_2023_lower_res.tif")

precip_df <- raster::extract(precip_uganda_resampled, wgs84_coords)%>%
 tibble(precip = .,
    Sample_code  = wgs84_coords$Sample_code)
pal_precip <- colorNumeric("Spectral", domain = c(0, 1))
leaflet() %>%
  addTiles() %>%
  addRasterImage(precip_uganda_resampled, opacity = 0.5)%>%
    addLegend(
    "bottomright",
    pal = pal_precip,
    values = c(0, 1),
  )

```

## Agroecological zone

```{r echo=FALSE}
wgs84_coords %>%
  left_join(cluster_agro_df, by = "Sample_code") %>%
  left_join(land_degradation_df, by = "Sample_code") %>%
  left_join(ndvi_df, by = "Sample_code") %>%
  left_join(precip_df, by = "Sample_code") -> wgs84_coords

```

## Some value at the sample level (extract from the raster)

```{r echo=FALSE}
pal_land_degradation <- colorFactor(myPal1[unique(land_degradation_df$ID)], 
                   domain = wgs84_coords$land_degra)

leaflet(wgs84_coords) %>%
  addTiles() %>%
  addRasterImage(land_degradation_raster, opacity = 0.7,
                 color = myPal1) %>%
  addCircleMarkers(
    ~lon, ~lat,
    color = "black",
    fillColor = ~pal_land_degradation(land_degra),
    radius = 6,
    weight = 2,
    stroke = T,
    fillOpacity = 0.8,
    popup = ~land_degra,
    label = ~Sample_code,
    group = ~land_degra
  ) %>%
   addLegend(
    "bottomright",
    pal = colorFactor(palette=myPal1, domain = land_degradation_type$land_degra),
    values = land_degradation_type$land_degra,
    title = "Land Degradation"
  )

# Cluster agro map with circle markers

pal_cluster_agro <- colorFactor(myPal3[1:8], domain = levels(cluster_agro_raster)[[1]]$Cluster)

leaflet(wgs84_coords) %>%
  addTiles() %>%
  addRasterImage(cluster_agro_raster, opacity = 0.7, color = myPal3) %>%
  addCircleMarkers(
    ~lon, ~lat,
    color = "black",
    fillColor = ~pal_cluster_agro(Cluster),
    radius = 6,
    weight = 2,
    stroke = TRUE,
    fillOpacity = 0.8,
    popup = ~Cluster,
    label = ~Sample_code,
    group = ~Cluster
  ) %>%
  addLegend(
    "bottomright",
    pal = colorFactor(palette = myPal3, domain = cluster_agro_type$Cluster),
    values = cluster_agro_type$Cluster,
    title = "Agro-ecological cluster"
  )
```

# Joint species distribution models at the genus level

```{r echo=FALSE}
amf_genus_rare <- read.table("outputs/abundance_tables/Robust_MiSeq_18S_AMf_20241120_125_samples.OTU.filtered.cleaved.nosubstringOTUs.mumu.rarefy.Glomeromycota_genus.txt", header = TRUE, stringsAsFactors = FALSE)
genus_tree <- read.tree("outputs/phylo_tree/Robust_MiSeq_18S_AMf_20241120_125_samples_Eukaryome_Glomeromycota_genus.tree")

# Inspect and root tree
genus_tree$tip.label
plot(genus_tree)
genus_tree <- root(genus_tree, "c__Archaeosporomycetes_4")

# Clean tip labels (example transformation)
genus_rename <- genus_tree$tip.label %>%
  str_remove("g__") %>%
  str_replace_all("[a-z]__", "Unknown ") %>%
  str_replace("_(\\d+)$", " (\\1 OTU)")
length(genus_rename)
genus_tree$tip.label <- genus_rename
plot(genus_tree)
str(genus_tree)

```
## Setup training and testing samples

```{r}
set.seed(13897356)
colnames(amf_genus_rare) -> soil_code
ncol(amf_genus_rare) -> n_samples

sample(1:n_samples, round(n_samples*0.8)) -> sample_selection

soil_code[sample_selection] -> training_samples 
soil_code[-sample_selection] -> testing_samples 

# Verification of length and absence of duplicate between training and test

length(training_samples)
length(testing_samples)
any(testing_samples %in% training_samples) 
any(training_samples %in% testing_samples)

```

```{r}
# Prepare Y matrix for families
amf_genus_rare <- amf_genus_rare %>%
  mutate(genus = genus %>%
           str_remove("g__") %>%
           str_replace_all("[a-z]__", "Unknown ") %>%
           str_replace("_(\\d+)$", " (\\1 OTU)")) %>%
  remove_rownames() %>%
  column_to_rownames("genus")

Y_genus <- amf_genus_rare %>%
  filter(rowSums(across(starts_with("ROB")) != 0) > 3) %>%
  t()

# Prepare Y without zeros as a truncated version
Y_genus_trucated <- Y_genus %>%
  as.data.frame() %>%
  rownames_to_column("soil_code") %>%
  pivot_longer(-soil_code) %>%
  mutate(value = ifelse(value == 0, NA, value)) %>%
  pivot_wider(names_from = name, values_from = value) %>%
  column_to_rownames("soil_code")

# Filter tree to the families present in Y
genus_tree_filter <- keep.tip(phy = genus_tree, tip = colnames(Y_genus))
Y_genus_trucated <- Y_genus_trucated[, genus_tree_filter$tip.label]

# Sample names from Y
genus_matrix_samples <- rownames(Y_genus)


Y_genus_trucated %>%
  rownames_to_column("soil_code") %>%
  filter(soil_code  %in% training_samples) %>%
  column_to_rownames("soil_code")  -> amf_genus_rare_training

Y_genus %>%
  as.data.frame() %>%
  rownames_to_column("soil_code") %>%
  filter(soil_code %in% testing_samples) %>%
  column_to_rownames("soil_code") -> amf_genus_rare_testing

colSums(amf_genus_rare_training, na.rm = T)

colSums(amf_genus_rare_testing, na.rm = T)
```

## Covariates

```{r}
covariate_df <- wgs84_coords %>%
  as.data.frame() %>%
  mutate(Sample_code = str_c("ROB_", Sample_code, "_s")) %>%
  filter(Sample_code %in% genus_matrix_samples) %>%
  dplyr::select(-geometry) %>%
  mutate(
    across(where(is.character), ~ as.factor(.x)),
    Cluster = factor(Cluster, levels = unique(Cluster)),
    land_degra = factor(land_degra, levels = c("Low", "Medium", "High"))
  )


# write.table(covariate_df, "outputs/covariate_table.txt")

```


```{r}
covariate_df %>%
  filter(Sample_code %in% training_samples) -> covariate_training

covariate_df %>%
  filter(Sample_code %in% testing_samples) %>%
  dplyr::select(Sample_code,Cluster, land_degra, ndvi, precip) -> covariate_testing

```


```{r echo=FALSE}
library(Hmsc)

nChains = 12
test.run = F
if (test.run){
  #with this option, the vignette runs fast but results are not reliable
  thin = 5
  samples = 10
  transient = 5*thin
  verbose = 5*thin
} else {
  #with this option, the vignette evaluates slow but it reproduces the results of the
  #.pdf version
  thin = 10
  samples = 500
  transient = 1000*thin
  verbose = 1000*thin
}
studyDesign <- data.frame(sample = rownames(amf_genus_rare_training), stringsAsFactors = TRUE)
rL <- HmscRandomLevel(units = studyDesign$sample)

```


```{r echo=FALSE}
mod_pois <- Hmsc(
  Y = amf_genus_rare_training,
  XData = covariate_training,
  XFormula = ~Cluster + land_degra + ndvi + precip,
  phyloTree = genus_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "poisson"
)

# m_converg <- sampleMcmc(
#   mod_pois,
#   thin = thin, samples = samples, transient = transient,
#   nChains = nChains, verbose = verbose, nParallel = 12
# )
# save(m_converg, file = "outputs/hmsc_genus.Rdata")
load(file = "outputs/hmsc_genus.Rdata")

```

```{r echo=FALSE}
# Binary presence/absence Y
Y_genus_bin <- amf_genus_rare_training %>%
  as.data.frame() %>%
  rownames_to_column("soil_code") %>%
  pivot_longer(-soil_code) %>%
  mutate(value = ifelse(is.na(value), 0, 1)) %>%
  pivot_wider(names_from = name, values_from = value) %>%
  column_to_rownames("soil_code")

mod_bin <- Hmsc(
  Y = Y_genus_bin,
  XData = covariate_training,
  XFormula = ~Cluster + land_degra + ndvi + precip,
  phyloTree = genus_tree_filter,
  studyDesign = studyDesign,
  ranLevels = list(sample = rL),
  distr = "probit"
)

# m_converg_bin <- sampleMcmc(
#   mod_bin,
#   thin = thin, samples = samples, transient = transient,
#   nChains = nChains, verbose = verbose, nParallel = 12
# )
# save(m_converg_bin, file = "outputs/hmsc_genus_bin.Rdata")
load(file = "outputs/hmsc_genus_bin.Rdata")
```

```{r include=FALSE}
postBeta2 <- getPostEstimate(m_converg, parName = "Beta")
beta_results <- postBeta2$mean
mpost2 <- convertToCodaObject(m_converg)
gelman.diag(mpost2$Beta, multivariate = FALSE) -> gelman_diag_df2
gelman_diag_df2$psrf

postBeta_bin2 <- getPostEstimate(m_converg_bin, parName = "Beta")
mpost_bin2 <- convertToCodaObject(m_converg_bin)
gelman.diag(mpost_bin2$Beta, multivariate = FALSE) -> gelman_diag_bin_df2
gelman_diag_bin_df2$psrf

beta_results <- postBeta2$mean
rownames(beta_results) <- colnames(m_converg$X)
beta_results <- beta_results * ((postBeta2$support > 0.9) + (postBeta2$support < (1 - 0.9)) > 0)
beta_results <- t(beta_results)[genus_tree_filter$tip.label, colnames(m_converg$X)]
colnames(beta_results) <- c("Intercept", "Cluster B", "Cluster C", "Cluster E", "LD Medium", "LD High", "NDVI", "Rain")

```

## Models results

### genus response to each varaibles

Estimated response of each genus to environmental variable with phylogenetic tree. 

Response of abundance :

```{r echo=FALSE}
library(ggtree)
p <- ggtree(genus_tree_filter, layout = "roundrect") +
  geom_tiplab(align = TRUE) +
  theme_tree()

gheatmap(p, beta_results, offset = 1, width = 1, font.size = 5,
         colnames_angle = -60, hjust = 0) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", na.value = "grey90",
                       limits = c(min(beta_results), max(beta_results))) +
  scale_y_continuous(expand = c(0, 5)) +
  labs(fill = "Parameters\nvalues")
```

Response of occurrences :

```{r echo=FALSE}

# Binary betas
beta_bin_results <- postBeta_bin2$mean
rownames(beta_bin_results) <- colnames(m_converg_bin$X)
beta_bin_results <- beta_bin_results * ((postBeta_bin2$support > 0.9) + (postBeta_bin2$support < (1 - 0.9)) > 0)
beta_bin_results <- t(beta_bin_results)[genus_tree_filter$tip.label, colnames(m_converg_bin$X)]
colnames(beta_bin_results) <- c("Intercept", "Cluster B", "Cluster C", "Cluster E", "LD Medium", "LD High", "NDVI", "Rain")

p_bin <- ggtree(genus_tree_filter, layout = "roundrect") +
  geom_tiplab(align = TRUE) +
  theme_tree()

gheatmap(p_bin, beta_bin_results, offset = 1, width = 1, font.size = 5,
         colnames_angle = -60, hjust = 0) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", na.value = "grey90",
                       limits = c(min(beta_bin_results), max(beta_bin_results))) +
  scale_y_continuous(expand = c(0, 5)) +
  labs(fill = "Parameters\nvalues")

```

### Phylogenetic signal

Abundances : 

```{r echo=FALSE}
gelman.diag(mpost2$Rho)$psrf
summary(mpost2$Rho)
```

Occurences : 

```{r echo=FALSE}
gelman.diag(mpost_bin2$Rho)$psrf
summary(mpost_bin2$Rho)
```


```{r include=FALSE}
library(nlme)
library(purrr)
# ------------------------------------------------------------------
# Compute Pagel's lambda for each covariate via nlme gls + corPagel
# ------------------------------------------------------------------
models <- list(abund = m_converg, bin = m_converg_bin)

compute.padgel.lambda <- function(models, i) {
  m <- models[[i]]
  postBeta <- getPostEstimate(m, parName = "Beta")
  phyloTree <- m$phyloTree
  nc <- dim(postBeta$mean)[1]

  results <- matrix(NA, nrow = nrow(postBeta$mean), ncol = 4) %>%
    as.data.frame() %>%
    rename(lambda = "V1", p_value = "V2", model = "V3", covariate = "V4")

  control <- glsControl(opt = "optim", msVerbose = TRUE)

  for (j in 1:nc) {
    y <- postBeta$mean[j, ]
    m1 <- gls(y ~ 1)
    m2 <- gls(y ~ 1, correlation = corPagel(0.5, phyloTree, fixed = FALSE, form = ~names(y)), control = control)
    z1 <- summary(m2)
    z2 <- anova(m1, m2)
    lambda <- z1$modelStruct[1]$corStruct
    pvalue <- z2$`p-value`[2]

    results$p_value[j] <- pvalue
    results$lambda[j] <- lambda
    results$model[j] <- i
    results$covariate[j] <- colnames(m$X)[j]
  }
  return(results)
}

any(branching.times(genus_tree_filter) == 0)

c("abund", "bin") %>%
  purrr::map(\(x) compute.padgel.lambda(models, x)) %>%
  list_rbind() -> lambda_df


```


```{r echo=FALSE}
lambda_df %>%
  knitr::kable()
```

Lambda is a metric that characterize phylogenetic signal. Here we characterize how response is related to phylogeny. When Lambda is close to 1 closely related species will have the same responses to environmental variable. When Lambda is close to 0 responses to environmental variables are random across the phylogeny. Here some reponses of occurrences and abundances are strongly phylogenically structure.

Some reference for this metric : 

https://doi.org/10.1111/j.2041-210X.2012.00196.x

https://doi.org/10.1111/1365-2745.13839

```{r echo=FALSE}
lambda_df %>%
  filter(p_value <= 0.05) %>%
  ggplot() +
  geom_point(aes(lambda, covariate, col = model), cex = 4) +
  theme_classic() +
  theme(
    axis.title.y = element_blank(),
    axis.text.x = element_text(colour = "black", size = 13, face = "italic", angle = 90, vjust = 0, hjust = 1),
    axis.text.y = element_text(colour = "black", size = 13, face = "italic"),
    axis.title = element_text(colour = "black", size = 16),
    panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
    legend.title = element_text(colour = "black", size = 16, hjust = 0.5),
    legend.text = element_text(colour = "black", size = 13)
  )
```


### Variance partitonning

Variance explain by each variables for each genus


abundances: 

```{r echo=FALSE, warning=FALSE}
VP2 <- computeVariancePartitioning(m_converg, na.ignore = TRUE)


VP2$vals %>%
  as.data.frame() %>%
  rownames_to_column("var") %>%
  pivot_longer(-var) %>%
  ggplot() +
  geom_col(aes(x = name, y = value, fill = var)) +
  theme_classic() +
  theme(
    axis.title.y = element_blank(),
    axis.text.x = element_text(colour = "black", size = 9, face = "italic", angle = 45, vjust = 1, hjust = 1),
    axis.text.y = element_text(colour = "black", size = 13, face = "italic"),
    axis.title = element_text(colour = "black", size = 16),
    panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
    legend.title = element_text(colour = "black", size = 16, hjust = 0.5),
    legend.text = element_text(colour = "black", size = 13)
  ) +
  ggsci::scale_fill_simpsons()


```

Occurrences :

```{r echo=FALSE, warning=FALSE}

VP_bin2 <- computeVariancePartitioning(m_converg_bin, na.ignore = TRUE)
VP_bin2$vals %>%
  as.data.frame() %>%
  rownames_to_column("var") %>%
  pivot_longer(-var) %>%
  ggplot() +
  geom_col(aes(x = name, y = value, fill = var)) +
  theme_classic() +
  theme(
    axis.title.y = element_blank(),
    axis.text.x = element_text(colour = "black", size = 9, face = "italic", angle = 45, vjust = 1, hjust = 1),
    axis.text.y = element_text(colour = "black", size = 13, face = "italic"),
    axis.title = element_text(colour = "black", size = 16),
    panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
    legend.title = element_text(colour = "black", size = 16, hjust = 0.5),
    legend.text = element_text(colour = "black", size = 13)
  ) +
  ggsci::scale_fill_simpsons()
```


### Residuals correlation matrix

Correlation between each genus when all the environmental variable have been accounted for.

Those figures show unexplained correlation caused by omitted biotic or abiotic variables

Abundances :

```{r echo=FALSE}
library(corrplot)

OmegaCor <- computeAssociations(m_converg)
supportLevel <- 0.95
toPlot <- ((OmegaCor[[1]]$support > supportLevel) + (OmegaCor[[1]]$support < (1 - supportLevel)) > 0) * OmegaCor[[1]]$mean

corrplot(toPlot, method = "color", col = colorRampPalette(c("blue", "white", "red"))(200),
         tl.cex = 0.6, tl.col = "black",
         title = paste("random effect level:", m_converg$rLNames[1]),
         mar = c(0, 0, 1, 0), order = "hclust")
```

Occurrences : 

```{r echo=FALSE}
OmegaCor_bin <- computeAssociations(m_converg_bin)
toPlot_bin <- ((OmegaCor_bin[[1]]$support > supportLevel) + (OmegaCor_bin[[1]]$support < (1 - supportLevel)) > 0) * OmegaCor_bin[[1]]$mean

corrplot(toPlot_bin, method = "color", col = colorRampPalette(c("blue", "white", "red"))(200),
         tl.cex = 0.6, tl.col = "black",
         title = paste("random effect level:", m_converg_bin$rLNames[1]),
         mar = c(0, 0, 1, 0), order = "hclust")
```

### Spatial extrapolation

Coffee plantation occur only at specific Land cover types thus I filter location (pixels) keep only those land cover types (this is why we have big white area on land)

```{r echo=FALSE}
land_degradation_raster_df <- rasterToPoints(land_degradation_raster) %>%
  as.data.frame() %>%
  mutate(land_degra = factor(land_degra, labels = levels(land_degradation_raster)[[1]]$land_degra))

cluster_agro_df <- rasterToPoints(cluster_agro_raster) %>%
  as.data.frame() %>%
  mutate(Cluster = factor(Cluster, labels = levels(cluster_agro_raster)[[1]]$Cluster))

ndvi_raster_df <- rasterToPoints(ndvi_uganda) %>%
  as.data.frame() %>%
  rename(ndvi = "ndvi_uganda_lower_res")

precip_raster_df <- rasterToPoints(precip_uganda_resampled) %>%
  as.data.frame() %>%
  rename(precip = "precip_2023_lower_res")

data_spatial_df <- cluster_agro_df %>%
  left_join(land_degradation_raster_df, by = join_by("x", "y")) %>%
  left_join(ndvi_raster_df, by = join_by("x", "y")) %>%
  left_join(precip_raster_df, by = join_by("x", "y")) %>%
  mutate(
    Cluster = case_when(!(Cluster %in% unique(covariate_df$Cluster)) ~ NA_character_, .default = Cluster),
    Cluster = as.factor(as.character(Cluster))
  ) %>%
  na.omit()
```

# Cross validation

```{r}
Gradient <- prepareGradient(mod_pois, XDataNew = covariate_testing)
predY_test <- stats::predict(m_converg, Gradient = Gradient)

Gradient2 <- prepareGradient(mod_bin, XDataNew = covariate_testing)
predY2_test <- stats::predict(m_converg_bin, Gradient = Gradient2)

EpredY_test <- predY_test[[1]]
EpredY2_test<- predY2_test[[1]]

# Average over predictions
EpredY_test = Reduce("+", predY_test)/length(predY_test)
EpredY2_test = Reduce("+", predY2_test)/length(predY2_test)

rownames(EpredY_test) <- covariate_testing$Sample_code
rownames(EpredY2_test) <- covariate_testing$Sample_code
```


```{r}
getS <- function(p){return(rowSums(p))}

# Posterior  distribution of speccies richness
aS <- simplify2array(lapply(X = predY2_test, FUN = getS))

ES = apply(aS, 1, mean) 
sdS = sqrt(apply(aS, 1, var)) 
S25 = apply(aS > 25, 1, mean)
```

```{r}
Y_genus_bin_test <- amf_genus_rare_testing %>%
  as.data.frame() %>%
  rownames_to_column("soil_code") %>%
  pivot_longer(-soil_code) %>%
  mutate(value = ifelse(value==0, 0, 1)) %>%
  pivot_wider(names_from = name, values_from = value) %>%
  column_to_rownames("soil_code")

rowSums(Y_genus_bin_test) %>%
  as.data.frame() %>%
  rownames_to_column("soil_code") %>%
  rename(obs_richness = ".") -> obs_richness_df
t(aS) %>%
  as.data.frame() %>%
  rename_with(~as.character(covariate_testing$Sample_code)) %>%
  pivot_longer(everything(), names_to = "soil_code",values_to = "estimted_richness") %>% 
  left_join(obs_richness_df, by = "soil_code") %>%
  ggplot() +
  geom_histogram(aes(estimted_richness)) +
  geom_vline(aes(xintercept = obs_richness), col = "orange") +
  facet_wrap(~soil_code) 
```


```{r}
library(caret)
library(purrr)

amf_genus_rare_testing %>%
  as.data.frame() %>%
  rownames_to_column("soil_code") %>%
  pivot_longer(-soil_code, names_to = "genus_names", values_to = "true_occurence") %>%
  mutate(true_occurence = ifelse(true_occurence==0, 0,1)) -> test_samples_bin_long

df_roc_AUC = data.frame(threshold =  seq(0.01, 1, length.out = 100),
                        Accuracy = NA,
                        TPR = NA,
                        FPR = NA)

for (n in 1:100){
  threshold <- df_roc_AUC[n,1]
  temp_pred <- EpredY2_test
  temp_pred[temp_pred<=threshold] <- 0
  temp_pred[temp_pred>threshold] <- 1

  temp_pred %>%
    as.data.frame() %>%
    rownames_to_column("soil_code") %>%
    pivot_longer(-soil_code, names_to = "genus_names", values_to = "pred_abund")%>%
    left_join(test_samples_bin_long, by = join_by(genus_names,soil_code)) -> temp_pred_long

  confusion_mat <- confusionMatrix(data = factor(temp_pred_long$pred_abund,levels = c(0,1)),
                             reference = factor(temp_pred_long$true_occurence))
  
  df_roc_AUC[n,2] = confusion_mat$overall[["Accuracy"]]
  df_roc_AUC[n,3] = confusion_mat$table[2,2]/(confusion_mat$table[2,2]+confusion_mat$table[1,2])
  df_roc_AUC[n,4] = confusion_mat$table[2,1]/(confusion_mat$table[2,1]+confusion_mat$table[1,1])
}

ggplot(data=df_roc_AUC) +
  geom_step(aes(x=FPR,y=TPR), size=1) +
  geom_ribbon(aes(x=FPR,ymin=0,ymax=TPR),
              alpha=0.2) +
  coord_cartesian(xlim = c(0,1), ylim=c(0,1.01), expand = FALSE) +
  geom_line(aes(x=seq(0,1,length.out =100), y=seq(0,1,length.out =100)), linetype='dashed') +
  labs(x='False Positive Rate', y='True Positive Rate',
       title = 'ROC curve of the model <model_name>')

ggplot(data=df_roc_AUC) +
  geom_line(aes(x=threshold,y=Accuracy), size=1) +
  #geom_line(aes(x=seq(0,1,length.out =100), y=seq(0,1,length.out =100)), linetype='dashed') +
  labs(x='Threshold', y='Accuracy',
       title = 'ROC curve of the model <model_name>')
```

```{r}
df_roc_AUC %>%
  filter(TPR>0.75, FPR<0.4)
df_roc_AUC %>%
  filter(Accuracy>0.7)
df_roc_AUC %>%
  filter( FPR<0.1 )


```


```{r}
EpredY_hurdel <- EpredY_test
EpredY_hurdel[EpredY2_test <0.39] <- 0
```

```{r}
EpredY_hurdel %>%
  as.data.frame() %>%
  rownames_to_column("soil_code") %>%
  pivot_longer(-soil_code, names_to = "genus_names", values_to = "pred_abund") -> EpredY_long

amf_genus_rare_testing %>%
  as.data.frame() %>%
  rownames_to_column("soil_code") %>%
  pivot_longer(-soil_code, names_to = "genus_names", values_to = "true_abund") -> test_samples_long

EpredY_long %>%
  left_join(test_samples_long, by = join_by(genus_names,soil_code)) -> abund_test_df


```

```{r}


abund_test_df %>%
  ggplot()+
  facet_wrap(~genus_names, scale = "free") +
  geom_point(aes(true_abund,pred_abund)) +
  labs(x= "Observed abundances", y = "Predicted abudances")

abund_test_df %>%
  mutate(diff = true_abund - pred_abund ) %>%
  group_by(genus_names) %>%
  summarise(n = n(),
            median_abund = median(true_abund, na.rm = T),
             mean_abund = mean(true_abund, na.rm = T),
            sd_abund = sd(true_abund, na.rm = T),
    RMSE = sqrt(sum(diff**2)/n))
  
```

# Prediction

```{r echo=FALSE}
library(viridis)

data_spatial_df %>%
  pivot_longer(c(Cluster, land_degra)) %>%
  ggplot() +
  facet_wrap(~name) +
  geom_raster(aes(x, y, fill = value))

# Prepare grid for gradient predictions
xy.grid <- data_spatial_df %>%
  dplyr::select(x, y) %>%
  as.matrix()

XData.grid <- data_spatial_df %>%
  dplyr::select(-c(x, y))

Gradient <- prepareGradient(mod_pois, XDataNew = XData.grid, sDataNew = list(route = xy.grid))
predY <- stats::predict(m_converg2, Gradient = Gradient)

Gradient2 <- prepareGradient(mod_bin, XDataNew = XData.grid, sDataNew = list(route = xy.grid))
predY2 <- stats::predict(m_converg_bin, Gradient = Gradient2)

EpredY <- predY[[1]]
EpredY2 <- predY2[[1]]

# Average over predictions
if (length(predY) > 1) {
  for (i in 2:length(predY)) {
    EpredY <- EpredY + predY[[i]]
    if (i %% 1000 == 0) print(i)
  }
  EpredY <- EpredY / length(predY)
}

if (length(predY2) > 1) {
  for (i in 2:length(predY2)) {
    EpredY2 <- EpredY2 + predY2[[i]]
    if (i %% 1000 == 0) print(i)
  }
  EpredY2 <- EpredY2 / length(predY2)
}
# save(EpredY, file = "outputs/prediction_abudance.Rdata")
# save(EpredY2, file = "outputs/prediction_occurence.Rdata")

load(file = "outputs/prediction_abudance.Rdata")
load(file = "outputs/prediction_occurence.Rdata")

data_spatial_df %>%
    bind_cols(EpredY) %>%
    pivot_longer(-c(x, y, Cluster, land_degra, ndvi, precip)) %>%
    mutate(value = log10(value + 1)) %>%
    ggplot() +
    facet_wrap(~name) +
    geom_raster(aes(x, y, fill = value)) +
    scale_fill_viridis(option = "cividis", direction = -1) +
    labs(x = "Lon", y = "Lat", fill = "Abundance (log10)") +
    theme_classic() +
    theme(
      aspect.ratio = 1,
      plot.margin = margin(0, 0, 0, 0),
      axis.title.x = element_blank(),
      panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
      axis.title.y = element_text(colour = "black", size = 14, face = "italic")
    )

data_spatial_df %>%
    bind_cols(EpredY2) %>%
    pivot_longer(-c(x, y, Cluster, land_degra, ndvi, precip)) %>%
    ggplot() +
    facet_wrap(~name) +
    geom_raster(aes(x, y, fill = value)) +
    scale_fill_viridis(option = "magma", direction = -1) +
    labs(x = "Lon", y = "Lat", fill = "Occurrence probability") +
    theme_classic() +
    theme(
      aspect.ratio = 1,
      plot.margin = margin(0, 0, 0, 0),
      axis.title.x = element_blank(),
      panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
      axis.title.y = element_text(colour = "black", size = 14, face = "italic")
    )

 ug_border <- read_sf("data/ug_shp/ug.shp")

 data_spatial_df %>%
    bind_cols(EpredY2) %>%
    pivot_longer(-c(x, y, Cluster, land_degra, ndvi, precip)) %>%
    group_by(x, y) %>%
    summarise(richness = sum(value, na.rm = TRUE), .groups = "drop") %>%
    ggplot() +
    geom_sf(data = ug_border) +
    geom_raster(aes(x, y, fill = richness)) +
    scale_fill_viridis(option = "viridis", direction = -1) +
    labs(x = "Lon", y = "Lat", fill = "genus richness") +
    theme_classic() +
    theme(
      aspect.ratio = 1,
      plot.margin = margin(0, 0, 0, 0),
      axis.title.x = element_blank(),
      panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
      axis.title.y = element_text(colour = "black", size = 14, face = "italic")
    )
 
```

```{r}
partition = createPartition(m_converg2, nfolds = 2, column = "sample")
partition.sp = c(rep(1,7),rep(2,7))

preds = computePredictedValues(m_converg2, partition = partition, partition.sp = partition.sp, mcmcStep = 10, nParallel = 12)
#save(preds, file = "outputs/cross_validation_sim.RData")
MF = evaluateModelFit(hM = m_converg2, predY = preds)
```



